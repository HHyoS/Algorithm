문제 사이트 : https://softeer.ai/practice/info.do?idx=1&eid=393&sw_prbl_sbms_sn=126167

문제 설명 :

    남북으로 흐르는 개울에 동서로 징검다리가 놓여져 있다.
    
    이 징검다리의 돌은 들쑥날쑥하여 높이가 모두 다르다. 
    
    이번에 철수는 개울의 서쪽에서 동쪽으로 높이가 점점 높은 돌을 밟다가 높이가 점점 낮은 돌을 밟으면서 개울을 지나가려고 한다. 
    
    돌의 높이가 서쪽의 돌부터 동쪽방향으로 주어졌을 때 철수가 밟을 수 있는 돌의 최대 개수는? 

제약조건

    1 ≤ N ≤ 3 × 105 인 정수

    1 ≤ Ai ≤ 108

입력형식

    첫 번째 줄에 돌의 개수 N이 주어진다. 
    
    두 번째 줄에 돌의 높이 Ai (1 ≤ i ≤ N)가 서쪽부터 동쪽으로 차례로 주어진다. 

출력형식

    첫 번째 줄에 철수가 밟을 수 있는 돌의 최대 개수를 출력하라.

입력예제1

    5
    3 2 4 5 1

출력예제1

    4
    
풀이 알고리즘

    푸는데 굉장히 오래걸린 문제 징검다리2 입니다.
    
    입력값의 갯수가 30만개이므로 2중for문을 사용할 경우 반드시 시간초과가 발생하는 문제였고, 
    
    log2(30)의 복잡도는 약 18.xxx 이므로 N*log(N)의 시간복잡도는 540만이되므로, N*log(N)의 계산을 두번하면
    
    시간초과가 발생할 수 있는 문제였습니다.
    
    제가 실패한 풀이를 말하면 길게 작성하게 되므로 정답풀이를 작성하도록 하겠습니다.
    
    1. 0번 index에서 시작하여 N-1 번 인덱스까지 최장길이 수열을 찾습니다.
    
    2. 찾는 과정에서 특정 index에 도달했을 떄, 해당 위치까지의 최장길이 수열을 만든 곳의 최대값(최장길이 수열의
    
    마지막 값)을 해당 배열에 저장합니다.
    
    3. N-1부터 0번 인덱스까지 탐색하여 최장길이 수열을 만들고, 특정 index에 도착했을 때 2번에서 작성한 최대값과
    
    해당 위치의 값이 일치한다면 0 ~ 최대값, 최대값 ~ N-1  의 징검다리가 완성됩니다.
    
    4. 3번의 징검다리가 완성되면 최대값 위치가 중복되어 계산되므로 두 값을 더한 뒤 1을 뺴면 정답이 됩니다.
    
    5. 하지만 돌이 두개인 경우, 올라가거나 내려가거나 둘 중 하나의 움직임만 가능하므로 하나의 돌을 밟은 뒤
    
    개울을 건너가게 됩니다. 이런 케이스에는 3번의 징검다리 만들기가 안되므로 임의로 1을 정답으로 출력해줍니다.
    
 풀이 인증샷 
 
 ![image](https://user-images.githubusercontent.com/57944215/212066059-83015e61-d7e2-4ef3-9286-69bf9b0aeb10.png)

 ![image](https://user-images.githubusercontent.com/57944215/212065995-b47becad-deb9-4db8-838f-f2145e9e0351.png)
