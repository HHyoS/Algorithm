![defaultImage](https://user-images.githubusercontent.com/57944215/213472044-6e51bcf6-50a3-474f-8c7b-1d43676962f0.png)

문제 사이트 : https://softeer.ai/practice/info.do?idx=1&eid=804&sw_prbl_sbms_sn=135411

문제 설명 :

    대학교 학부생활을 마치고 현대자동차에 프로그래머로 취직한 사회초년생 현빈이는 팀장님에게 보안에 관련한 지식이 하나도 없음을 들키고 말았다. 
    
    그래서 현빈이는 업무시간 틈틈이 보안과 관련된 주제들을 공부하고 있다.

    오늘 공부할 주제는 암호화 방식중 하나인 Playfair cipher(플레이페어 암호)다. 
    
    Playfair cipher는 알파벳으로 이루어진 어떤 문자열(평문; plaintext)을 암호화하는 방법으로, 이를 위해 알파벳으로 이루어진 문자열인 키(key)가 필요하다.
    
    Playfair cipher는 빈도분석을 어렵게 하기 위해 한번에 두 글자 단위로 암호화를 진행하며, 
    
    5×5크기의 표를 사용하기 때문에 알파벳 26개를 모두 담기에는 칸이 한 개 부족해 I와 J를 동일한 것으로 생각한다. 
    
    이 문제에서는 편의상 J가 아예 주어지지 않는다.

    먼저, 주어진 키를 5×5크기의 표로 변환한다. 키를 한 글자씩 보면서 왼쪽 위 칸부터 한줄씩 표를 채운다. 
    
    만약 이전에 봤던 알파벳이 한번 더 등장하면 무시하고 다음 글자를 보면 된다. 
    
    키를 다 보고도 칸이 남는다면, 아직 등장하지 않은 알파벳을 순서대로 채워넣으면 된다. 
    
    예를 들어 키가 PLAYFAIRCIPHERKEY라면 다음과 같이 표가 만들어진다. 
    
    굵게 표시된 알파벳이 키를 통해 채워진 알파벳이다.
    
![20211217_173746926_52835](https://user-images.githubusercontent.com/57944215/213472280-6522a0c7-6111-46de-9788-d32fba27b3aa.png)

    다음 일은 암호화하려는 메세지를 두 글자씩 나누는 일이다. 

    예를 들어, HELLOWORLD라는 메세지를 두 글자씩 나눈다면 HE LL OW OR LD가 된다. 

    LL같이 두 글자로 이루어진 쌍이 생기면 중간에 다른 글자를 넣어 쌍을 파괴해줘야 한다.

    이렇게 같은 두 글자로 이루어진 쌍이 생기면 그 중 가장 앞에 있는 쌍 사이에 X를 넣고 뒤쪽은 새롭게 쌍을 구성하면 된다. 

    만약, 쌍이 XX였다면 X를 넣어서는 해결이 안되기 때문에 Q를 넣는 것으로 해결 한다. 

    이렇게 쌍을 모두 맞추고 마지막에 한 글자가 남는다면 이것도 암호화가 불가능하기 때문에 여기도 X를 덧붙여 강제로 쌍을 맞춰준다.

    마지막 남은 한 글자가 X인 경우에는 예외적으로 XX로 쌍을 맞춘다.

    그러므로, HELLOWORLD를 두 글자씩 나누는 올바른 방법은 HE LX LO WO RL DX이고, XXYYY를 두 글자씩 나누는 올바른 방법은 XQ XY YX YX가 된다. 

    마지막으로, 쌍을 만든 두 글자를 암호화하는 일이 남았다. 다음과 같은 세 가지 경우가 있는데, 위에서 만든 5×5표를 통해 설명해본다.

    (1) 만약, 두 글자가 표에서 같은 행에 존재하면, 오른쪽으로 한 칸 이동한 칸에 적힌 글자로 암호화된다. 
       
    예를 들어 HE를 암호화하면 EI가 되고, XX를 암호화하면 ZZ가 된다. 
       
    위치가 다섯 번째 열이라면 첫 번째 열로 이동하게 된다.
    
    
![20211217_174122154_84160](https://user-images.githubusercontent.com/57944215/213472573-b7c8a688-cc73-4103-b93b-c15d39049c2d.png)

    (2) (1)의 경우를 만족하지 않으면서 두 글자가 표에서 같은 열에 존재하면, 아래쪽으로 한 칸 이동한 칸에 적힌 글자로 암호화된다. 
    
    예를 들어 LO를 암호화하면 RV가 된다. 
    
    위치가 다섯 번째 행이라면 첫 번째 행으로 이동하게 된다.
    
![20211217_174255968_61302](https://user-images.githubusercontent.com/57944215/213472732-f1f96b7d-5e54-49f5-9ec9-a0574d47a9e5.png)

    (3)  (1),(2)의 경우를 만족하지 않으면서, 두 글자가 표에서 서로 다른 행, 열에 존재하면, 
    
    두 글자가 위치하는 칸의 열이 서로 교환된 위치에 적힌 글자로 암호화된다. 
    
    예를 들어 LX를 암호화하면 YV가 된다.
    
![20211217_174318391_49786](https://user-images.githubusercontent.com/57944215/213472863-ad7b0f34-1535-40bf-8072-9f26b961ff4b.png)

    이 과정에 따르면, HELLOWORLD를 Playfair cipher로 암호화한 결과는 EIYVRVVQBRGW가 된다.

    현빈이는 어떤 메세지와 키가 주어졌을 때 주어진 메세지를 Playfair cipher로 암호화하려고 한다.
    
제약조건

    메세지의 길이는 1 이상 1,000 이하이다.
    키의 길이는 1 이상 100 이하이다.

입력형식

    첫 번째 줄에 J를 제외한 알파벳 대문자로 이루어진 메세지가 주어진다.
    두 번째 줄에 J를 제외한 알파벳 대문자로 이루어진 키가 주어진다.

출력형식

    첫 번째 줄에 Playfair cipher로 암호화된 결과를 출력한다.

입력예제1

    HELLOWORLD
    PLAYFAIRCIPHERKEY

출력예제1

    EIYVRVVQBRGW

입력예제2

    LEMONSTRAWBERRYAPPLEIUICE
    WATERMELON

출력예제2

    NALNBQEWTANRTZEZTKKOWQWUGW
    
풀이 알고리즘

    주어진 조건에 맞게 문자열을 시뮬레이션하고, 암호화된 문자열을 출력하는 문제 플레이페어 입니다.
    
    문제의 조건에 맞추어 시뮬레이션하면 해결할 수 있는 문제였지만, 좀 더 편하게 풀기 위해
    
    각 알파뱃의위치를 저장하는 구조체 배열을 만들어서 사용하였습니다.
    
    문제에서 요구하는 시뮬레이션은 다음과 같습니다.
    
    1. 문제에서 주어진 Key를 이용하여 5X5 표로 변환하기
    
    2. 문제에서 주어진 입력값을 두개씩 구분하여 연속된 문자열이 있다면 'X'를, 연속된 문자열이 있다면 'Q'로 바꿔주기
    
    3. 2 의 과정 종료 이후 문자열의 길이가 홀수라면 'X' 추가해주기
    
    4. 3 의 과정이 끝난후 문자열 암호화하기
    
       1) 묶인 두개의 문자열이 한 행에 존재하면, 각 문자열을 1 에서 만든 표를 기준으로 한 열씩 이동시키기(->)
       
       2) 묶인 두개의 문자열이 1) 의 조건은 만족하지 않지만 같은 행에 존재할 경우
       
           각 문자열을 1 에서 만든 표를 기준으로 한 행씩 이동시키기(아래로)
           
       3) 묶인 두개의 문자열이 1),2) 두 조건을 모두 만족시키기 않을 경우
       
           각 문자열의 열 위치를 바꿔주기 ex) A = {x1,y1}, B = {x2,y2} 일경우 A = 표[x1][y2] B = 표[x2][y1]
           
풀이 인증샷 

![image](https://user-images.githubusercontent.com/57944215/213474995-3867bfd5-df57-4aad-9353-e09fc10f89fd.png)

![image](https://user-images.githubusercontent.com/57944215/213475057-765f8374-2b4e-4b5f-8293-46e374158bc9.png)

    
