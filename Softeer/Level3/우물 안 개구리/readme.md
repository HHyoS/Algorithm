![8cba17c4-8e26-46d5-be3c-1649edf3a09f](https://user-images.githubusercontent.com/57944215/215331153-1acc5745-91ba-4eff-a9c6-d8a671339b90.jpg)

문제 사이트 : https://softeer.ai/practice/info.do?idx=1&eid=394&sw_prbl_sbms_sn=137786

문제 설명 :

    헬스장에서 N명의 회원이 운동을 하고 있다. 
    
    각 회원은 1에서 N사이의 번호가 부여되어 있고, i번 회원이 들 수 있는 역기의 무게는 Wi이다.
    
    회원들 사이에는 M개의 친분관계 (Aj, Bj)가 있다. 
    
    (Aj, Bj)는 Aj번 회원과 Bj번 회원이 친분 관계가 있다는 것을 의미한다.
    
    i번 회원은 자신과 친분 관계가 있는 다른 회원보다 들 수 있는 역기의 무게가 무거우면 자신이 최고라고 생각한다.
    
    단, 누구와도 친분이 없는 멤버는 본인이 최고라고 생각한다.



    이 헬스장에서 자신이 최고라고 생각하는 회원은 몇 명인가? 

제약조건

    2 ≤ N ≤ 105
    1 ≤ M ≤ 105
    1 ≤ Wi ≤ 109
    1 ≤ Aj, Bj ≤ N
    Aj ≠ Bj

입력형식

    첫 번째 줄에 두 정수 N, M이 주어진다.
    두 번째 줄에 N개의 정수 W1, W2, ... , WN 이 주어진다.

    다음 M개의 줄의 j번째 줄에는 두 정수 Aj, Bj 가 주어진다.

출력형식

    첫 번째 줄에 자신이 최고라고 생각하는 회원 수를 출력한다.

입력예제1

    5 3
    1 2 3 4 5
    1 3
    2 4
    2 5

출력예제1

    3

입력예제2

    5 3
    7 5 7 7 1
    1 2
    2 3
    3 4

출력예제2


    2
    
풀이 알고리즘

    Union-Find로 구현했다가 틀리고, 단순구현으로 맞춘 문제 '우물 안 개구리'입니다.
    
    그룹지어서 푸는 문제만 보면 자꾸 Union-Find로 풀게되서 무작정 구현했는데, 문제에서 의미하는 '친분'이 '친분'을 타고 연결된
    
    '친분'과는 비교하지 않는다는것을 너무 늦게 알아버렸습니다.
    
    이 문제의 풀이는 매우 단순합니다.
    
    1. 문제의 정보를 입력받는다.
    
    2. '친분' 관계 정보가 들어오면, A와 B를 비교하여 
    
        1) A가 더 크다 : B는 최고가 되지 못한 인물로 처리합니다.
        2) B가 더 크다 : A는 최고가 되지 못한 인물로 처리합니다.
        3) A와 B가 같다 : A와 B 둘다 최고가 되지 못한 인물로 처리합니다.
    
    3. for문을 N만큼 돌면서 최고가 되지못한 인물을 제외한 모든 인물의 수를 세어 출력합니다.
    
풀이 인증샷  

![image](https://user-images.githubusercontent.com/57944215/215331387-855c5a5a-be24-4886-a8e4-6bb247167cd3.png)


 ![image](https://user-images.githubusercontent.com/57944215/215331412-ee466c0c-7e9b-4622-b884-d68abc30aa01.png)
   
    
