![cf73559c-8f7f-4a97-a5e3-51e6f0a2ab4e](https://user-images.githubusercontent.com/57944215/215754464-367f5d40-0866-4037-8f82-daf0f32ccf84.jpg)

문제 사이트 : https://softeer.ai/practice/info.do?idx=1&eid=411&sw_prbl_sbms_sn=138593

문제 설명 :

    북위 65도. 스웨덴의 소도시 아르예플로그(Arjeplog)에 자리한 동계 테스트 센터.
    
    겨울 내내 얼음 두께가 1M 내외로 유지되는 광할한 얼음 호수와 그냥 걷기조차 힘든 눈길을 무대로 
    
    현대자동차그룹 연구원들은 극한 환경 속에서 더 나은 차량 성능을 확보하기 위해 제동안정성, 주행안정성,
    
    ADAS 기능 등에 대한 다양한 평가를 숨가쁘게 이어가고 있다.

    이 곳은 기온이 너무 추워서 아침에 출근해보면 테스트 차량들 위에 큰 눈얼음이 생겨 있다. 
    
    정상적인 테스트를 위해서는 커다란 얼음이 어느정도 녹고 난 뒤에 가능한데, 
    
    차량 마다 당일의 테스트 가능 시점을 알기 위한 예측 프로그램을 제작 중에 있다. 

![20210908_185703938_53293](https://user-images.githubusercontent.com/57944215/215754552-125bea1e-91e9-4600-bf13-aa127613ad9d.jpg)


    예측 프로그램은 N×M (5 ≤ N, M ≤ 100)의 격자 화면 위에 눈 얼음의 모양을 작은 정사각형들이 집합되어 있는 
    
    모양으로 변환하여 위 그림과 같이 표시해 준다. 
    
    단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 
    
    이 얼음은 아침이 되면 기온이 상승하여 천천히 녹는다.

    그런데 화면에서 나타난 얼음의 모양은 작은 정사각형 모양의 4변 중에서 적어도 2변 이상이 외부의 공기와 접촉했을 때 
    
    정확히 한 시간 만에 녹아 없어져 버린다. 
    
    따라서 위 그림의 모양과 같은 얼음(파란으로 표시된 부분)라면 C로 표시된 모든 얼음 격자는 한 시간 후에 사라진다.

![20210908_185744179_67764](https://user-images.githubusercontent.com/57944215/215754559-ccf3d0e4-2f84-482e-ab8f-d22cd1f17ec9.jpg)


    위와 같이 얼음 내부에 있는 공간은 얼음 외부 공기와 접촉하지 않는 것으로 가정한다.
    
    그러므로 이 공간에 접촉한 얼음 격자는 녹지 않고 C로 표시된 얼음 격자만 사라진다. 
    
    그러나 한 시간 후, 이 공간으로 외부공기가 유입되면, 아래 그림에서와 같이 C로 표시된 얼음 격자들이 사라지게 된다.

![20210908_185830051_00278](https://user-images.githubusercontent.com/57944215/215754584-3690e091-f221-4d1c-b4af-d8886cba172e.jpg)


    격자 화면의 맨 가장자리에는 얼음이 놓이지 않는 것으로 가정한다. 
    
    입력으로 주어진 얼음이 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성해보자. 

제약조건

    5 ≤ N, M ≤ 100

입력형식

    첫째 줄에는 격자 화면의 크기를 나타내는 두 개의 정수 N, M이 주어진다. 
    
    그 다음 N개의 줄에는 격자 화면 위에 얼음이 있는 부분은 1로 표시되고, 
    
    얼음이 없는 부분은 0으로 표시된다. 또한, 각 0과 1은 하나의 공백으로 분리되어 있다. 

출력형식

    출력으로는 주어진 얼음이 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.

입력예제1

    8 9
    0 0 0 0 0 0 0 0 0
    0 0 0 1 1 0 0 0 0
    0 0 0 1 1 0 1 1 0
    0 0 1 1 1 1 1 1 0
    0 0 1 1 1 1 1 0 0
    0 0 1 1 0 1 1 0 0
    0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0

출력예제1

    4

풀이 알고리즘 :

    혼자서 열심히 어렵게 푼 문제 '동계 테스트 시점' 입니다.
    
    제가 푼 알고리즘 풀이부터 설명드리겠습니다.
    
        1. (입력) 입력값을 map 배열에 넣고, 얼음의 위치를 찾는으면 얼음의 갯수를 세줍니다.

        2. (초기세팅) bfs탐색을 돌며 방문하지 않은 공간을 찾고, 특정 공간을 방문했을 때, 해당 위치가 얼음과 인접하다면

            인접공간을 표시하는 queue에 넣어줍니다.

        3. (풀이) 인접공간을 모두 찾았다면, 인접공간이 담긴 queue값을 모두 꺼내 얼음과 마찰시키고, 2번이상 마찰된 얼음은

        없애준 뒤, 해당 얼음부터 시작하여 bfs탐색을 돌며 인접공간에 포함되지 않은 위치들을 인접공간 que에 넣어줍니다.

        4. (풀이) 3과정에서 한번도 얼음을 만나지 못한 입접공간은 다시 탐색하지 않고, 한번이라도 얼음과 마찰된 인접공간은

        다시 인접공간 que에 넣어 다음 탐색에도 사용합니다.

        5. 3의 과정에서 마찰된 얼음이 없어졌을 때, 1에서 카운팅한 얼음의 갯수를 하나 줄여줍니다.

        6. 5의 과정에서 엄음의 갯수가 0이 되었다면 3 ~ 5의 한 사이클이 몇회 반복되었는지 출력하면 답입니다.
    
    쉬운 풀이....
    
        N과 M의 값이 100*100 이므로 1회 완전탐색을 돌려도 10,000회 배열을 탐색합니다.
        
        최악의 케이스르 생각해도 최대 100번 탐색을 진행하므로 100만번* 4방향 탐색을 진행하는데, 그렇게되면 0.04초
        
        정도 걸리므로 시간내에 해결할 수 있습니다.
        
        그래서 그냥 .... 
        
            1. 0.0부터 시작하는 dfs탐색을 하며, 인접한 공간에 얼음이 있다면 카운트 해주고, 

            2. dfs탐색이 끝나면 얼음이 두번이상 마찰되었는지 확인하고 2번이상이면 해당 얼음을 빈 공간으로 표시.

            3. 얼음이 남아있는지 확인하고, 얼음이 없다면 1 ~3 사이클 진행한 횟수 출력
        
        으로 해결됩니다.
        
        N이나 M이 컸다면, 제 풀이가 맞는 방법일수도 있지만, N과 M이 작으므로, 위 방법으로 푸는게 더 효율적이였을 것 같습니다.
        
        ㅠㅠ...
    

풀이 인증샷 

![image](https://user-images.githubusercontent.com/57944215/215754433-f6df0450-47ab-4324-9621-cb345a1fcba2.png)

![image](https://user-images.githubusercontent.com/57944215/215754389-a773b265-6015-4406-99cf-fefa47244b58.png)
