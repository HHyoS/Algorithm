문제 사이트 :

문제 설명 :

    옷장을 정리해야 하는데 옷이 너무 많아 옷장 바닥에 흘러넘친다. 
    
    옷걸이를 걸 수 있는 위치는 N개고, 옷걸이는 M개가 있다.
    
    이때 아주 놀라운 사실을 깨달았는데, 
    
    옷장 크기에 비해 옷걸이가 많을 경우 옷걸이에 옷걸이를 걸면 옷을 더 많이 걸 수 있다는 사실이다 !!!

![upload acmicpc](https://user-images.githubusercontent.com/57944215/145981600-2bef1188-de07-4eee-b492-63487e243187.png)


    옷걸이에 옷을 거는 대신 양쪽에 옷걸이를 걸면 옷을 더 걸 수 있는데,
    
    옷걸이의 균형을 위해 옷걸이의 양쪽에 걸리는 옷걸이의 총 개수가 같은 완전 이진 옷걸이를 만들어야 한다.
    
    이때 당연히 옷걸이가 걸리지 않은 맨 아래 옷걸이에만 옷을 걸 수 있다.

    옷걸이 하나를 높이가 1인 옷걸이 트리라 할 때, 옷걸이 양쪽에 옷걸이 두 개를 걸면 높이 2인 옷걸이 트리가 된다.
    
    이를 반복하여 옷걸이 양쪽에 높이 i인 옷걸이 트리를 걸면 높이 i+1인 옷걸이 트리가 된다. 
    
    옷장의 높이가 낮아 높이 3 이하인 옷걸이 트리에만 옷을 걸 수 있다. 
    
    높이가 4인 옷걸이 트리는 옷장에 넣을 수 있지만 높이 때문에 밑에 옷을 걸 수 없고,
    
    높이가 5 이상인 옷걸이 트리는 옷장에 넣을 수 없다. 옷걸이를 둘 다른 장소가 없어 옷걸이를 남김없이 사용해야 하며,
    
    모든 옷걸이를 걸 수 있는 위치에 옷걸이 트리를 배치할 필요는 없다.

    조건을 만족하며 옷걸이 트리를 배치할 때 걸 수 있는 옷의 최대 수를 구하시오.

입력

    첫 번째 줄에 옷걸이를 걸 수 있는 위치의 개수와 옷걸이의 수 $N, M$가 주어진다. ($1\leq N \leq5,000, 1\leq M \leq 10,000$)

출력

    첫 번째 줄에 최대로 걸 수 있는 옷의 개수를 출력한다. 만약 위의 조건을 만족하며 $M$개의 옷걸이를 $N$개 이하의 위치에 걸 방법이 없다면 $-1$을 출력한다.

예제 입력 1 

    4 14
    
예제 출력 1 

    9
    
풀이 알고리즘

        1. 첫번쨰 옷걸이 공간에서 놓을 수 있는 옷걸이의 경우의 수는 0,1,3,7,15 개이고, 두번쨰 이상부터는 이전단계에 가능한 옷걸리의 수 + 1,3,5,7의 케이스가 가능하게됩니다.
        2. 이를 점화식으로 세우면 dp[1][0] = 0, dp[1][1] = 1, dp[1][3] = 2, dp[1][7] =3, dp[1][15] = 0 을 기본값으로 세팅해두고
        3. 2 <= a <= n; 1 <= b <= m 범위의 2중 for문을 진행하며 dp[a][b] = max(dp[a-1][b-1]+1, dp[a-1][b-3] +2, dp[a-1][b-7]+4, dp[a-1][b-15]) 를 반복하며 갱신시키고
        4. 모든 연산이 종료되면 max(dp[1~n][m]) 를 출력하면 문제가 해결됩니다.
        
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <utility>
    #include <vector>
    using namespace std;
    int n, m;

    int dp[5001][10001];

    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
      //freopen("Input.txt", "r", stdin);
      cin >> n >> m;
      for (int a = 0; a <= n; ++a) {
        for (int b = 0; b <= m; ++b) {
          if (b == 0)
            dp[a][b] = 0;
          else
            dp[a][b] = -1;
        }
      }
      dp[1][1] = 1;
      dp[1][3] = 2;
      dp[1][7] = 4;
      dp[1][15] = 0;
      for (int a = 2; a <= n; ++a) {
        for (int b = 1; b <= m; ++b) {
                if(b > a*15)
                    break;
          int big = -1;
          if ((b - 15 >= 0) && (dp[a - 1][b - 15] >= 0))
            big = max(big, dp[a - 1][b - 15]);
          if ((b - 1 >= 0) && dp[a - 1][b - 1] >= 0)
            big = max(big,dp[a - 1][b - 1] + 1);
          if ((b - 3 >= 0) && (dp[a - 1][b - 3] >= 0))
            big = max(big, dp[a - 1][b - 3] + 2);
          if ((b - 7 >= 0) && (dp[a - 1][b - 7]  >= 0))
            big = max(big, dp[a - 1][b - 7] + 4);
          dp[a][b] = big;
        }
      }
      int big = -1;
      for (int a = 1; a <= n; ++a) {
        big = max(big, dp[a][m]);
      }
      cout << big;
      return 0;
    }

