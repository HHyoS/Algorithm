문제 사이트 : https://www.acmicpc.net/problem/1037

문제 설명 :

	양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 
	
	어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.

입력

	첫째 줄에 N의 진짜 약수의 개수가 주어진다. 
	
	이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다.
	
	1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.

출력

	첫째 줄에 N을 출력한다. N은 항상 32비트 부호있는 정수로 표현할 수 있다.

예제 입력 1 

	2
	4 2

예제 출력 1 

	8

예제 입력 2 

	1
	2

예제 출력 2 

	4

예제 입력 3 

	6
	3 4 2 12 6 8

예제 출력 3 

	24

예제 입력 4 

	14
	14 26456 2 28 13228 3307 7 23149 8 6614 46298 56 4 92596

공통 풀이 방법

    1) 주어진 소수의 갯수가 50개임이 주어져있다.
    2) 1과 주어진 N값은 소수에 포함되어 있지않다.
    3) 주어진 소수는 불규칙하게 주어져있다.
  
 Divisor.cpp 풀이방법
 
    1. 1) 의 최대가 정해져있으므로 크기가 50인 int배열을 선언하여 입력받은 값을 저장
    2. 저장된 값을 sort하면 맨 앞과 맨 뒤의 값을 곱하면 원래의 수 N이 나온다.
 
 Divisor(no_array) 풀이방법
 
    1. 중간의 다른 값들은 중요하지않다. 가장 큰값과 가장 작은값을 찾아보자
    2. 가장 큰값과 작은값을 저장하는 변수를 선언하고, 입력받은 값과 비교하여 가장 큰값과 작은값을 찾아내서 곱하면 N을 찾을 수있다.
    
주요 알고리즘

1. Divisor.cpp


		int arr[51]; // 입력받은 수를 저장할 int 배열 (공약수의 갯수가 최대 50개이므로)

		for (int a = 1; a <= n; ++a)
		  cin >> arr[a];

		sort(arr, arr + n + 1); // 입력받은 배열을 sort하면
		cout << arr[1] * arr[n]; // 가장 앞의 약수와 가장 큰 수를 곱하면 원래의 수 N

2. Divisor(no_array).cpp


		int big = -1; // 모든 소수는 양수이므로 음수를 big으로 설정
		int sm = 1000001; // 가장 큰값이 1,000,000 이므로 1,000,001 을 가장 작은 값으로 설정
		int num; 
		for (int a = 0; a < n; ++a) { // n개의 소수를 입력받으면서
			cin >> num;
			if (big < num) // 입력받은 값이 big보다 크다면 big = num
				big = num;
			if (sm > num) // 입력받은 값이 sm 보다 작으면 sm = num
				sm = num;
		}
