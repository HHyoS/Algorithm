문제 사이트 : https://www.acmicpc.net/problem/1309

문제 설명 :

    어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.



    이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다.
    
    이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

    동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자.
    
    사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

입력

    첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

출력

    첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

예제 입력 1 

    4

예제 출력 1 

    41
    

풀이 알고리즘

    1. 사자를 놓는 케이스는 (1) 아얘 배치를 안할때 (2) 1열 배치 (3) 2열 배치 세가지입니다.
    2. 이전 케이스에 의한 현재 배치 조건은 다음과 같습니다.
        (1) 아얘 배치를 안 할 떄 = 이전 행에서 무슨 배치를 했는지 상관이 없음
        (2) 1열에 배치 할 때 = 이전 행에서 [ 배치를 안함 ] or [ 2열 배치 ]
        (3) 2열에 배치 할 떄 = 이전 행에서 [ 배치를 안함 ] or [ 1열 배치 ]
    3. 계산 결과를 9901로 나누어야 하므로, int 범위 내에서 처리하기 위해 dp알고리즘을 실행하며 나머지연산 실시.
    
[ 구 현 ]

1. 사용 전역 변수 

        int n;
        int dp[2][3];
        
   (1) n = 입력받는 값으로, 동물원 행의 길이
   (2) dp[2][3] = 가능한 방법의 갯수를 저장하는 배열로, 
       계산 과정에서 필요한 값이 이전값 뿐이기 떄문에, 현재값을 저장할 공간과 이전값을 저장할 공간만을 선언하여 메모리사용을 줄였습니다.
       
2. DP 구현

        dp[1][0] = 1; // 1줄에 안넣은 경우
        dp[1][1] = 1; // 1줄 1열에 넣은 경우
        dp[1][2] = 1; // 1줄 2열에 넣은 경우
        
(1) 알고리즘 실행 전 초기값 세팅. 1열이 가질 수 있는 경우의 수는 위의 주석과 같습니다.
   
        int answer = 0;
        bool now;
        bool before;
        
(2) 사용할 변수들로, answer는 답을 저장할 변수, now는 현재 위치 before는 이전 값의 위치를 나타낼 커서의 역할을 할 예정입니다.
   
   
        for (int a = 2; a <= n; ++a) {
          now = a % 2;
          before = (a + 1) % 2;
          dp[now][0] = (dp[before][0] + dp[before][1] + dp[before][2]) % 9901;
          dp[now][1] = (dp[before][0] + dp[before][2]) % 9901;
          dp[now][2] = (dp[before][0] + dp[before][1]) % 9901;
        }
        
(3) 구현한 DP코드로, 현재 작성할 배열의 위치와 이전 배열의 위치를 line 70~71에서 저장해두고, [ 풀이 알고리즘 ] 항목에서 작성한 것처럼
   
    Line 72 : 아얘 배치를 안 할 떄 = 이전 행에서 무슨 배치를 했는지 상관이 없음     
    Line 73 : 1열에 배치 할 때 = 이전 행에서 [ 배치를 안함 ] or [ 2열 배치 ]    
    Line 74 : 2열에 배치 할 떄 = 이전 행에서 [ 배치를 안함 ] or [ 1열 배치 ]
 3가지 조건에 맞추어 dp코드를 작성하고, 문제의 조건인 9901의 나머지연산을 계산과정에서 미리 진행하였습니다.
        
        int last = n % 2;
        answer = (dp[last][0] + dp[last][1] + dp[last][2]) % 9901;
        cout << answer;
        
(4) 결과를 출력하는 코드들로 마지막 dp를 갱신한 위치를 last변수에 저장하고, 모든 경우의 수를 저장한 answer를 출력!
    
