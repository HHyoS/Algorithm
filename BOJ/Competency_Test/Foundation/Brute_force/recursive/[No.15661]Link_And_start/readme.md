문제 사이트 : https://www.acmicpc.net/problem/15661

문제 설명 :

    오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다.
    
    축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이다.
    
    이제 스타트 팀과 링크 팀으로 사람들을 나눠야 한다. 두 팀의 인원수는 같지 않아도 되지만, 한 명 이상이어야 한다.

    BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다.
    
    능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 
    
    팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. 
    
    Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.

    N=4이고, S가 아래와 같은 경우를 살펴보자.


    i\j	1	2	3	4

    1	 	1	2	3

    2	4	 	5	6

    3	7	1	 	2


    4	3	4	5	 

    예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.


    스타트 팀: S12 + S21 = 1 + 4 = 5

    링크 팀: S34 + S43 = 2 + 5 = 7

    1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.


    스타트 팀: S13 + S31 = 2 + 7 = 9

    링크 팀: S24 + S42 = 6 + 4 = 10

    축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 
    
    위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 

    능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.


입력

    첫째 줄에 N(4 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 
    
    각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 

    같고, 100보다 작거나 같은 정수이다.


출력

        첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.

예제 입력 1 

    4

    0 1 2 3

    4 0 5 6

    7 1 0 2

    3 4 5 0

예제 출력 1 

    0

예제 입력 2 

    6

    0 1 2 3 4 5

    1 0 2 3 4 5

    1 2 0 3 4 5

    1 2 3 0 4 5

    1 2 3 4 0 5

    1 2 3 4 5 0

예제 출력 2 

    2

예제 입력 3 

    8

    0 5 4 5 4 5 4 5

    4 0 5 1 2 3 4 5

    9 8 0 1 2 3 1 2

    9 9 9 0 9 9 9 9

    1 1 1 1 0 1 1 1

    8 7 6 5 4 0 3 2

    9 1 9 1 9 1 0 9

    6 5 4 3 2 1 9 0

예제 출력 3 

    1

예제 입력 4 

    5

    0 3 1 1 1

    3 0 1 1 1

    1 1 0 1 1

    1 1 1 0 1

    1 1 1 1 0

예제 출력 4 

    0

풀이 알고리즘

    1. 한 팀의 최소인원이 한명도 가능하다고 써져있지만, 두 명 이상이 팀을 이루어야 능력치가 생기므로 팀의 최소인원은 여섯명
    2. S[i,j] 와 S[j,i]가 다르다고 했지만, 결국 S[i,j] + S[j,i] = 팀의 능력치 이므로 크게 신경써야 할 부분은 아님
    3. DFS탐색을 통해 팀이 ( 2 : N-2 ) , ( 3 : N - 3) .... (N-2 : 2) 까지 탐색을 진행해야하지만, 
    ( 2: N -2) 와 ( N - 2 : 2 ) 는 두 값의 차가 같으므로 탐색의 범위를 반으로 줄여서 계산
    
    
[ 구 현 ]


1. Main 핵심코드


        for (int a = 2; a <= n /2; ++a) {
            for (int b = 0; b <= n-a; ++b) {
                team[b] = 1;
                dfs(b, a-1);
                team[b] = 0;
            }
        }

  (1) 입력된 값을 바탕으로 하는 DFS탐색을 설정하는 코드
  
  (2) line 85는 팀의 인원수를 설정하는 부분으로, 팀원은 최소 2명부터 n / 2 명으로 설정
  
  (3) 팀의 인원이 역전되는 순간 중복이 발생하므로 ( ex) n = 5 일때, 최소값을 갖는 팀원이 2명 : 3명 일 때, 이 값을 구하기 위해 2 : 3 인 케이스와 3 : 2인 케이스 두번을 DFS탐색하므로 2로 나누어 중복제거)
  
  (4) line 86은 출발 index를 표시하는 for문으로 조건 b <= n-a 는 무조건 선택해야하는 갯수보다 남은 팀이 적은일이 없도록 하기위해 설정
  
  (5) line 87 ~ 89는 방문을 표시하고 dfs탐색을 진행하는 코드로 b의 위치를 탐색 시작하고, 해당 위치를 방문표시, DFS탐색 종료 후 방문표시 해제
  
  

2. DFS 핵심코드


        void dfs(int index, int count) {
        if (count == 0) {
            ssum();
            return;
        }


        if (index >= n)
            return;

        for (int b = index; b < n; ++b) {
                team[b] = 1;
                dfs(b+1, count -1);
                team[b] = 0;
        }
    }

 (1) line 109 ~ 112는 DFS탐색의 탈출조건 중 하나로, 목표로 정한 팀만큼 팀원을 선택했다면 팀의 차이를 계산하는 ssum 함수 호출 후 재귀 종료.
 
 (2) line 115 ~ 116은 DFS탐색의 두번째 탈출 조건으로, dfs탐색을 하며 이동시킨 범위가 주어진 범위보다 크가면 종료시키는 구문.
 
 (3) line 118 ~ 123은 다음 DFS탐색을 설정하는 부분으로, 현재 index(아직 방문표시를 하지않은)기준으로 이후의 팀원들을 대상으로 팀원으로 설정하고 DFS탐색 실시
 
 
 
3. ssum 함수

        void ssum() {
        int start[20], link[20];
        int s_count = 0, l_count = 0;

        for (int a = 0; a < n; a++) {
            if (team[a] == 0) {
                link[l_count] = a;
                ++l_count;
            }
            else {
                start[s_count] = a;
                ++s_count;
            }
        }

        int team_l = 0;
        int team_s = 0;
        for (int a = 0; a < s_count; ++a) {
            for (int b = a+1; b < s_count; ++b) {
                team_s += arr[start[a]][start[b]] + arr[start[b]][start[a]];
            }
        }
        for (int a = 0; a < l_count; ++a) {
            for (int b = a+1; b < l_count; ++b) {
                team_l += arr[link[a]][link[b]] + arr[link[b]][link[a]];
            }
        }
        int dif = abs(team_l - team_s);
            if (answer > dif) {
                answer = dif;
            }
        }
    
  (1) Link 팀과 Start팀의 차이를 계산하는 함수 ssum.
  
  (2) line 139 ~ 148은 앞의 dfs탐색을 통해 만들어진, 방문표시를 하는 배열 team을 이용하여 link팀과 start팀을 구분.
   
  (3) line 150 ~ 161은 구분된 팀을 바탕으로 각 팀별 능력치의 총합을 구하는 코드.
  
  (4) line 162 ~ 166은 주어진 팀들의 능력치 값을 바탕으로 값을 구하고 현재까지 구해진 능력이 차의 최소값 answer보다 작다면 해당 값은 answer로 저장.
  
  (5) algorithm 헤더파일에도 존재하는 함수로, 주어진 값잉 음수라면 양수로, 양수라면 그대로 반환해주는 함수로 간단한 코드이기 떄문에 직접 구현했습니다. 
  
4. abs 함수

        int abs(int x){
            if (x < 0) return x * -1;
            else return x;
        }
