문제 사이트 : https://www.acmicpc.net/problem/18290

문제 설명 :

    크기가 N×M인 격자판의 각 칸에 정수가 하나씩 들어있다.
    
    이 격자판에서 칸 K개를 선택할 것이고, 선택한 칸에 들어있는 수를 모두 더한 값의 최댓값을 구하려고 한다. 
    
    단, 선택한 두 칸이 인접하면 안된다. r행 c열에 있는 칸을 (r, c)라고 했을 때, 
    
    (r-1, c), (r+1, c), (r, c-1), (r, c+1)에 있는 칸이 인접한 칸이다.

입력

    첫째 줄에 N, M, K가 주어진다. 둘째 줄부터 N개의 줄에 격자판에 들어있는 수가 주어진다.

출력

    선택한 칸에 들어있는 수를 모두 더한 값의 최댓값을 출력한다.

제한

    1 ≤ N, M ≤ 10
    1 ≤ K ≤ min(4, N×M)
    격자판에 들어있는 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.
    항상 K개의 칸을 선택할 수 있는 경우만 입력으로 주어진다.
    
예제 입력 1 

    1 1 1
    1

예제 출력 1 

    1

예제 입력 2 

    2 2 2
    1 2
    3 4

예제 출력 2 

    5

예제 입력 3 

    2 2 2
    5 4
    4 5

예제 출력 3 

    10

예제 입력 4 

    5 5 3
    1 9 8 -2 0
    -1 9 8 -3 0
    -5 1 9 -1 0
    0 0 0 9 8
    9 9 9 0 0

예제 출력 4 

    27

풀이 알고리즘 
  
    1. N과 M의 최대값은 10이므로 10 x 10 의 int 배열을 생성
    2. 선택한 배열의 위,아래,좌,우 는 모두 사용불가로 체크 ( 사용 가능한지 체크하는 배열 필요 )
    3. dfs탐색을 하며 사용가능한 배열에 대해서만 탐색을진행하며 선택한 갯수를 더해나감
    4. 선택한 갯수가 입력값 K과 같아지면 현재까지 최대 값과 비교하여 가장 큰 값을 저장

[구  현]

1. 사용한 배열 목록과 변수

        #define MIN -9223372036854775808
        int arr[11][11];
        int able[11][11];
        int cant[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };
        long long big = MIN;

  (1) MIN : 가질 수 있는 최소값을 저장한 변수로, 배열에서 가질 수 있는 값이 -10000 이므로 -10000 * 10(가로 최대길이) * 10(세로 최대길이) 로 설정해도 되지만 long long의 최소값을 힐당
  
  (2) arr : 입력값을 저장하는 배열
  
  (3) able : 방문시 1을 더하여 방문표시를 하는 배열
  
  (4) cant : 특정위치 (x,y) 를 방문시 사용 불가능한 상, 하, 좌, 우 를 계산하기위해 만든 변수 
  
  (5) big : 최대값을 저장하는 변수로 MIN 을 저장하여 K 개의 배열을 선택 시 어떤 수가 와도 초기값이 될 수 있도록 가장 작은수를 저장
  
  
2. DFS 함수


        void dfs(long long num, int count) {
          if(count == k){
            if (big < num) {
              big = num;
            }
            return;
          }
          for (int a = 0; a < n; ++a) {
            for (int b = 0; b < m; ++b) {
              if (able[a][b] == 0) {
                for (int c = 0; c < 4; ++c) {
                  if ((a + cant[c][0] >= 0) && (a + cant[c][0] < n) && (b + cant[c][1] >= 0) && (b + cant[c][1] < m)) {
                    ++able[a + cant[c][0]][b + cant[c][1]];
                  }
                }

                answer[count] = arr[a][b];

                ++able[a][b];
                dfs(num + arr[a][b], count+1);
                --able[a][b];

                for (int c = 0; c < 4; ++c) {
                  if ((a + cant[c][0] >= 0) && (a + cant[c][0] < n) && (b + cant[c][1] >= 0) && (b + cant[c][1] < m)) {
                    --able[a + cant[c][0]][b + cant[c][1]];
                  }
                }
              }
            }
          }
        }
  (1) 탐색 알고리즘이 구현된 함수, 매개변수로 현재까지 선택한 값들의 합 num과 선택한 갯수 count를 넘겨받아 처리하는 함수
  
  (2) line 73 ~ 78 은 함수의 반복을 종료하는 코드로 count가 K와 같은때 if문을 통해 실행되고, 실행된 이후 big < num 을 만족하면 big에 num을 입력 후, dfs탐색을 종료합니다.
  
  (3) line 79 ~ 102 는 n * m 의 배열에서 다음 방문지로 방문 가능한 위치를 확인하고, 가능한 위치의 상, 하, 좌, 우 사용 불가로 표시하기위해 cant 배열을 이용하여 탐색블가 설정
  
  (3 - 1) 해당 for문 부분에 현재 수정이 필요해 보이는데, 초기에 (1,1) -> (2,2)를 방문한 케이스에 대해 (2,2) -> (1,1) 을 방문하는 케이스의 중복을 막지 못해서 불필요한 반복이 생기고있습니다.
  
  (3 - 2) 그래서 2차원 배열을 2중 for문이 아닌 한 칸씩 이동하면서 중복을 방지할 수 있는 방법을 찾아 구현해 보려고 합니다.
  
  (4) (3)의 수행이 끝난 이후 사용 불가로 표시했던 부분에 대해 사용 가능으로 변경하여 다음 반복에서 해당 부분을 다시 사용할 수 있도록 원상복구
  

3. main 함수


        int main() {

        ios::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        //freopen("Input.txt", "r", stdin);

        cin >> n >> m >> k;

        for (int a = 0; a < n; ++a) {
          for (int b = 0; b < m; ++b) {
            cin >> arr[a][b];
          }
        }
        for (int a = 0; a < n; ++a) {
          for (int b = 0; b < m; ++b) {
            for (int c = 0; c < 4; ++c) {
              if ((a + cant[c][0] >= 0) && (a + cant[c][0] < n) && (b + cant[c][1] >= 0) && (b + cant[c][1] < m)) {
                ++able[a + cant[c][0]][b + cant[c][1]];
              }
            }

            ++able[a][b];
            dfs(arr[a][b],1);
            --able[a][b];

            for (int c = 0; c < 4; ++c) {
              if ((a + cant[c][0] >= 0) && (a + cant[c][0] < n) && (b + cant[c][1] >= 0) && (b + cant[c][1] < m)) {
                --able[a + cant[c][0]][b + cant[c][1]];
              }
            }
          }
        }
        cout << big;

        return 0;
      }
  
  (1) 풀이 알고리즘의 main 함수
  
  (2) line 122 ~ 128 을 통해 n, m, k와 arr배열의 값을 입력받고
  
  (3) line 129 ~ 147 을 통해 dfs()와 같은 동작으로 초기값을 세팅하여 탐색을 진행하며 가장 큰 값 big을 찾아냅니다.
  
  (4) 이후 찾아낸 big 값 출력!
  
 
--------------------------시간 효율성 개선코드 NM_And_K(1)(Improve) 업로드--------------------------

[ 주요 변경 코드 ]

1. DFS 탐색

  
        ++y;
        if (y == m) y = 0, ++x;
        if (x == n) return;

        dfs(x, y, num, count);
        if (able[x][y] == 0) {
          for (int c = 0; c < 4; ++c) {
            if ((x + cant[c][0] >= 0) && (x + cant[c][0] < n) && (y + cant[c][1] >= 0) && (y + cant[c][1] < m)) {
              ++able[x + cant[c][0]][y + cant[c][1]];
            }
          }
          ++able[x][y];
          dfs(x, y, num + arr[x][y], count + 1);
          --able[x][y];

          for (int c = 0; c < 4; ++c) {
            if ((x + cant[c][0] >= 0) && (x + cant[c][0] < n) && (y + cant[c][1] >= 0) && (y + cant[c][1] < m)) {
              --able[x + cant[c][0]][y + cant[c][1]];
            }
          }
        }
        
   (1) 개선전 코드의 [ 구현 ] 부분에서 언급한 것처럼, (1,1) -> (2,2) 를 방문하는 케이스가 있어도, (2,2) -> (1,1) 을 방문하는 케이스를 걸러내지 못하는 불필요한 중복이 있었습니다.
   
   (2) 개선한 코드에서는 2중 for문이 아닌 배열의 열을 한칸씩 오른쪽으로 한칸씩 이동하며 탐색하는 방식으로, 기존 DFS 탐색에서는 2중 for문에 의해서 중복방문하는 케이스를 줄였습니다.
   
   (3) line 178 ~ 180 이 그것을 구현한 코드로 특정 배열을 DFS함수가 호출되면, 다음칸으로 이동하는 ++y 연산을 실행 후 y가 주어진 m의 크기를 벗어나면 x값, 즉 행을 하나 증가시키고 y의 값을 0으로 세팅합니다.
   
   (4) 그리고 x가 주어진 n의 범위를 벗어난다면 선택한 갯수가 모자른 상태로 탐색이 종료되므로 return시켜서 DFS을 종료합니다.
   
   (5) line 182 의 dfs(x,y,num,count)는 ++y을 이용하여 이동한 칸을 그냥 넘어간다는 의미로, 현재칸이 선택할수 있는 배열의 위치여도 선택하지 않고 넘어감을 의미합니다.
   
   (6) line 183 ~ 198 의 코드는 기존에 작성한 코드의 같은 의미를 하는 동작으로, 현재 칸이 선택 가능하다면 선택 후 상,하,좌,우 의 칸을 사용 불가로 만드는 연산을 진행합니다.
   
   (7)  코드 변경을 통해 처음에 실행시간이 1404 ms 였던 코드가 96 ms 로 14배 이상 시간이 개선 수 있었습니다.
   
