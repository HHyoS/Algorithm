문제 사이트 : https://www.acmicpc.net/problem/14391

문제 설명 : 

    영선이는 숫자가 쓰여 있는 직사각형 종이를 가지고 있다. 
    
    종이는 1×1 크기의 정사각형 칸으로 나누어져 있고, 숫자는 각 칸에 하나씩 쓰여 있다.
    
    행은 위에서부터 아래까지 번호가 매겨져 있고, 열은 왼쪽부터 오른쪽까지 번호가 매겨져 있다.

    영선이는 직사각형을 겹치지 않는 조각으로 자르려고 한다. 각 조각은 크기가 세로나 가로 크기가 1인 직사각형 모양이다. 
    
    길이가 N인 조각은 N자리 수로 나타낼 수 있다. 
    
    가로 조각은 왼쪽부터 오른쪽까지 수를 이어 붙인 것이고, 세로 조각은 위에서부터 아래까지 수를 이어붙인 것이다.

    아래 그림은 4×4 크기의 종이를 자른 한 가지 방법이다.

    각 조각의 합은 493 + 7160 + 23 + 58 + 9 + 45 + 91 = 7879 이다.

    종이를 적절히 잘라서 조각의 합을 최대로 하는 프로그램을 작성하시오.

입력

    첫째 줄에 종이 조각의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 4)

    둘째 줄부터 종이 조각이 주어진다. 각 칸에 쓰여 있는 숫자는 0부터 9까지 중 하나이다.

예제 입력 1

    2 3
    123
    312
    
예제 출력 1 

    435

코드 및 설명 : << 현재 구현 중.. dfs와 backtracking 방식을 이용하여 arr[0][0]부터 시작하여 한칸씩 이동하면서 모든 경우에 대해 가로, 세로 이동로 연산을 구현해보려고합니다. >>
 << 21.11.24 구현 완료 >>

    
[ 풀이 알고리즘 ]

        1. 특정 칸에서 할 수 있는 동작은 [ 가로 확장  ] 과 [ 세로 확장 ], 그리고 [ 다음칸으로 이동] 세 가지가 있습니다.
        
        2. 세 가지 탐색을 dfs로 구현할 때, 중복을 최소화하여 구현하는 방법은 현재 ( x , y ) 일 떄, 무조건 ( x , y + 1 ) 로 이동하여 풀이 알고리즘 (1)의 동작을 진행하는 것 입니다.
        
        3. ( x , y + 1 ) 로 이동했을 때 이미 사용중인 칸이라면 다음칸으로 이동하는 연산을 진행합니다.
        
        4. x와 y가 끝을 알리는 위치에 도달했을 때, 더한 값과 최대값을 비교하여 최대값 저장.
        

[ 구 현 ]

1. 전역 변수와 main 함수


        int n, m;
        int arr[4][4];
        bool check[4][4];
        int big = -1;
        
        int main() {

            /*ios::sync_with_stdio(0);
            cin.tie(0);
            cout.tie(0);*/

            freopen("Input.txt", "r", stdin);
            scanf("%d %d", &n, &m);
            for (int a = 0; a < n; ++a) {
                for (int b = 0; b < m; ++b) {
                    scanf("%1d", &arr[a][b]);
                }
            }
            dfs(0 , 0, 0); 
            printf("%d", big);
            return 0;
        }
        
            (1) 전역변수 : 
                n = 행, m = 열을 의미하고
                arr = 입력값을 저장
                check = 방문을 체크하는 배열입니다.
                big = 최대값을 저장하는 함수로 arr값으로 주어지는 값이 양수이므로, 절대 나올 수 없는 값인 음수 -1을 초기값으로 설정하였습니다.
            (2) main 함수 : 
                line 70 ~ 74 줄은 입력값을 저장하는 코드로, arr에 저장할 입력 정수가 연결되어 나오므로 하나씩 끊어서 저장하기위해 "%1d"를 사용하였습니다.
                line 75 의 dfs(0,0,0) 은 dfs를 시작하는 함수로 dfs(x 위치, y 위치, 현재까지 칸의 합)을 의미합니다.
  
2. DFS 함수

           if (y == m) {
                ++x;
                if (x == n) {
                    if (sum > big)
                        big = sum;
                    return;
                }
                y = 0;
            }
            
    (1) DFS의 탐색 중 (x,y+1)로 열 이동 했을 때 y값이 주어진 칸보다 커질경우 동작하는 if문으로 벗어날 을 경우 x값을 하나 증가시키고, x값이 범위를 벗어날 경우 dfs종료.
        아닐경우 y에 0을 입력하여 행이동 
                
        if (check[x][y])  // 현재 위치가 사용된 위치라면
        
            dfs(x, y + 1, sum); // 사용할 수 있는 연산이 없으므로 (x , y+1) 으로 열 이동
            
        else { // 현재 위치가 사용할 수 있는 위치라면
        
            check[x][y] = 1; // 현재 위치를 사용했음을 체크하고
            
            dfs(x, y + 1, sum + arr[x][y]); // 현재 칸의 값을 sum에 더하고, ( x , y+1 ) 로 이동하는 연산 실시
            
            int temp = arr[x][y]; // temp 변수에 현재 위치의 값을 저장하고
            
            for (int a = 1; x + a < n; ++a) { // a만크만 세로 확장 후 (x,y+1)로 이동하는 for문
            
                if (!check[x + a][y]) { // 현재 위치에서 a만큼 행 이동한 위치가 사용 가능이라면
                
                    for (int b = 1; b <= a; ++b) { // x + 1 ~ x + a 까지 
                    
                        check[x + b][y] = 1; // 사용체크
                    }
                    
                    temp = temp * 10 + arr[x + a][y]; // 세로로 확장 했으므로 현재 위치 (x,y) 의 자리수를 증가시키고, (x+a,y)의 값을 temp 에저장
                    
                    dfs(x, y + 1, sum + temp); // a만큼 세로 확장 후 위치는 (x,y+1)
                    
                    for (int b = 1; b <= a; ++b) { // a만큼 확장하여 사용표시했던 것들에 대해 
                        check[x + b][y] = 0; // 사용표시 해제
                    }
                }
                else // a만큼 행 이동시킨 (x+a, y)가 이미 사용중인 칸이라면
                    break; // for문 종료
            }
            temp = arr[x][y]; // 다시 temp에 arr[x][y] 저장 후 
            
            for (int a = 1; y + a < m; ++a) { // (x,y+1) 부터 (x, m-1) 까지 가로 확장
            
                if (!check[x][y + a]) { // (x , y+a) 위치가 사용 가능이라면
                
                    for (int b = 1; b <= a; ++b) { // x,y+1 부터 x + a 까지 사용표시
                        check[x][y + b] = 1;
                    }
                    
                    temp = temp * 10 + arr[x][y + a]; // 확장 할때마다 단위수 증가 및 (x,y+a)위치 값 더하기
                    
                    dfs(x, y + a +1, sum + temp); // y+a 까지 확장 시켰으므로, 다음 탐색 위치는 ( x , y + a + 1 )
                    
                    for (int b = 1; b <= a; ++b) { // x,y+1 부터 x + a 까지 사용표시 해제
                        check[x][y + b] = 0;
                    }
                }
                else // ( x , y + a ) 위치가 사용 중이라면
                    break; // for문 해제
            }
            check[x][y] = 0; // line 110에서 사용표시 했던 것에 대한 
        }
