문제 사이트 : https://www.acmicpc.net/problem/20055

문제 설명 :


    길이가 N인 컨베이어 벨트가 있고,
    
    길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 
    
![1](https://user-images.githubusercontent.com/57944215/145376266-8985f98c-5bf0-4e7b-a992-ee60c6be576a.png)
    
    벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 
    
    각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다.

![2](https://user-images.githubusercontent.com/57944215/145376386-0e9d0723-f21a-4a93-8cc9-20d2c86d8fe6.jpg)


    벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 
    
    2N번 칸은 1번 칸의 위치로 이동한다. 
    
    i번 칸의 내구도는 Ai이다. 
    
    위의 그림에서 1번 칸이 있는 위치를 "올리는 위치", N번 칸이 있는 위치를 "내리는 위치"라고 한다.

    컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다.
    
    언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 
    
    로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 
    
    로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다.

    컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다.
    
    로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다.

    벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.
    
    가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다.
    
    만약 이동할 수 없다면 가만히 있는다.
    
    로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다.
    
    올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.
    
    내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 
    
    그렇지 않다면 1번으로 돌아간다.
    
    종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 
    
    가장 처음 수행되는 단계는 1번째 단계이다.

입력

    첫째 줄에 N, K가 주어진다. 둘째 줄에는 A1, A2, ..., A2N이 주어진다.

출력

    몇 번째 단계가 진행 중일때 종료되었는지 출력한다.

제한

    2 ≤ N ≤ 100
    1 ≤ K ≤ 2N
    1 ≤ Ai ≤ 1,000
    
예제 입력 1 

    3 2
    1 2 1 2 1 2

예제 출력 1 

    2

예제 입력 2 

    3 6
    10 10 10 10 10 10

예제 출력 2 

    31

예제 입력 3 

    4 5
    10 1 10 6 3 4 8 2

예제 출력 3 

    24

예제 입력 4 

    5 8
    100 99 60 80 30 20 10 89 99 100

예제 출력 4 

    472
    
풀이 알고리즘

    1. 문제에서 제시하는대로의 동작을 구현하면 되는 문제로 밑의 조건들만 충분히 이해하면 풀 수 있는 문제였습니다.
    
    2. 이 문제의 풀이알고리즘은 크게 4가지 입니다.
        1) 벨트 회전
        2) 로봇 이동
        3) 로봇 올리기
        4) 로봇 내리기
        
    3. 로봇이 존재하는 범위는 로봇이 올라가는 [ 시작 ] 부터 로봇이 내리는 [ 종료 ] 지점까지입니다.
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <queue>
    using namespace std;
    int n, k; // 벨트의 길이 n, 내구도 0의 갯수 k
    int arr[200]; // 벨트 정보
    bool check[200]; // 벨트위에서 로봇이 존재하는 위치
    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);

      //freopen("Input.txt", "r", stdin);
      cin >> n >> k;
      queue<int> que;  // 순서에따라 로봇을 담는 que.

      for (int a = 0; a < 2 * n; ++a) {
        cin >> arr[a]; // 컨베이어벨트 정보 입력
      }
      int answer = 0;
      int start = 0, end = 0;
      int n_2 = n + n; // 컨베이어벨트 전체 크기 저장.

      while (k > 0) { // k가 1 이상이면 

        // 동작 1(컨베이어 벨트의 이동) 구현 시작
        start = (start + n_2 - 1) % n_2; // 로봇이 올라가는 위치 start는 1 ~ 2n의 범위에서 봣을 떄
        // 계속 한칸씩 뒤로가는것으로 볼 수 있습니다. 그러므로 (start + 2n -1) % 2n 을하면 한칸 부족한 한바퀴를
        // 돌기 떄문에, 한 칸 뒤로가는것과 동일한 동작을 할 수 있습니다.

        end = (start + n - 1) % n_2; // 로봇이 내리는 지점인 end는 start에서 n-1만큼 떨어진 곳에 위치하므로
        // (start + n -1) % 2n 으로 나누어 종료지점을 구했습니다.

        // 동작 1 구현 완료(컨베이어 벨트의 이동 대신, start와 end만을 이동시켜서 로봇이 벨틑가 이동하는것처럼
        // 동작 실시

        int size = que.size(); // 로봇이 담긴 que의 크기측정


        // 동작2 구현 시작(로봇 이동, 로봇 내리기)
        for (int a = 0; a < size; ++a) { // que에 담긴 로봇만큼 이동 for문 반복

          int robot = que.front(); // 로봇의 현재위치 robot
          int one_step = (robot + 1) % n_2; // 로봇의 다음위치 one_step
          que.pop(); // que에서 로봇을 제거해주고

          if (robot == end) { // 현재 로봇의 위치가 end와 같다면, 내려야 하므로
            check[robot] = 0; //robot의 위치 check[robot]을 0으로 바꾸어 로봇이 존재하지 않음을 표시
            continue;
          }

          else if ((arr[one_step] > 0) && !check[one_step]) {
          // 현재 위치하는 로봇의 다음칸이 내구도가 1이상이고, 로봇이 존재하지않는다면 

            check[robot] = 0; // 로봇이 움직일 것이기때문에 check에서 해제해주고

            if(one_step != end){ // 다음칸이 end가 아니라면
              que.push(one_step); // 다음칸으로 이동시킨 후 que에 넣어주고
              check[one_step] = 1; // check에 로봇이 있음을 표시
            } // end라면 로봇이 내리므로 push연산이 진행되지 않음.

            arr[one_step] -= 1;  // one_step 이동한 곳의 내구도 하나 깍고

            if (arr[one_step] == 0) // 깍은 내구도가 0이라면
              --k; // k를 줄여서 
          }
          else {
            que.push(robot); // 현재 칸이 end도 아니고, 다음칸으로 이동할 수 없다면, 로봇은 제자리에 그대로.
          }

          // 동작 2 구현 완료
        }

        // 동작 3 구현 시작(로봇 올리기)
        if (arr[start] > 0) { // 현재 start지점의 벨트의 내구도가 0이 아니라면
          if (arr[start] == 1) { // 만약 내구도가 1이라면, 0이 될것이므로
            --k; // k하나 줄여주고
          }
          que.push(start); // que에 start위치에 로봇추가
          arr[start] -= 1; // start 벨트의 내구도 줄이고
          check[start] = 1;  // check에 start위치 로봇존재 표시
        }
        //동작 3 구현 완료

        ++answer; // 한 단계마다 증가하는 변수 answer. 한 사이클이 끝났으므로 +1
      }
      cout << answer; // k가 0이 되어서 while문이 종료됫다면, 몇단계를 진행했는지 
      return 0;
    }


    
