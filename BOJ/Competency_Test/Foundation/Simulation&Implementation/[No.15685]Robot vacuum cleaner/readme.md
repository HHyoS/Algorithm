문제 사이트 : https://www.acmicpc.net/problem/14503

문제 설명 :

    로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.

    로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며,
    
    1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다.
    
    청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다.
    
    지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수,
    
    c는 서쪽으로 부터 떨어진 칸의 개수이다.

    로봇 청소기는 다음과 같이 작동한다.

    현재 위치를 청소한다.
    
    현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다.
    
    왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 
    
    그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
    
    왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
    
    네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 
    
    바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
    
    네 방향 모두 청소가 이미 되어있거나 벽이면서,
    
    뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
    
    로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.

입력

    첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)

    둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. 
    
    d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을,
    
    3인 경우에는 서쪽을 바라보고 있는 것이다.

    셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 
    
    각 줄은 서쪽부터 동쪽 순서대로 주어진다. 
    
    빈 칸은 0, 벽은 1로 주어진다. 
    
    지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.

    로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.

출력

    로봇 청소기가 청소하는 칸의 개수를 출력한다.

예제 입력 1 

    3 3
    1 1 0
    1 1 1
    1 0 1
    1 1 1

예제 출력 1 

    1

예제 입력 2 

    11 10
    7 4 0
    1 1 1 1 1 1 1 1 1 1
    1 0 0 0 0 0 0 0 0 1
    1 0 0 0 1 1 1 1 0 1
    1 0 0 1 1 0 0 0 0 1
    1 0 1 1 0 0 0 0 0 1
    1 0 0 0 0 0 0 0 0 1
    1 0 0 0 0 0 0 1 0 1
    1 0 0 0 0 0 1 1 0 1
    1 0 0 0 0 0 1 1 0 1
    1 0 0 0 0 0 0 0 0 1
    1 1 1 1 1 1 1 1 1 1

예제 출력 2 

    57
    
[ 풀이 알고리즘 ]

    문제에서 설명하는 조건에 맞추어 코드를 시뮬레이션하여 청소하는 칸의 갯수를 출력하는 문제입니다.
    
    문제의 풀이 알고리즘은 문제에서 설명하는 것과 같습니다.
    
    1. 현재 위치를 청소한다.
    
    2. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다.
    
        a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 
        그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
        
        b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
        
        c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는,
        바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
        
        d.  네 방향 모두 청소가 이미 되어있거나 벽이면서, 
        뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
        
    위의 알고리즘을 수행하기 위해 중요한것은 현재 진행하고 있는 방향으로 청소를 진행하는것이 아닌
    
    진행방향의 반시계 방향으로 돌면서 청소 가능한 위치를 찾고, 해당방향으로 이동 및 머리를 돌리는것이였습니다
    
    즉, 12시방향으로 청소를 진행하고 있으면 다음으로 청소를 탐색하는 방향은 9시이고
    
    다음 진행방향은 9시의 반시계 방향은 6시를 생각하며 구현하는것입니다.
    
    그래서 머리의 위치에 따라 이동하는 것과, 머리의 방향은 별도로 설정해주어 해결해야했습니다.
    
    그것 외에는 큰 어려움없이 구현할 수 있었습니다.
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    #include <utility>
    #include <vector>

    using namespace std;
    int N, M;
    bool map[50][50];
    bool check[50][50];
    int mov[4][2] = { {0,-1}, {-1,0},{0,1},{1,0} }; // 머리방향이 북, 동, 남 , 서 일 때 처음 탐색하는 위치
    int bak[4][2] = { {1,0},{0,-1},{-1,0},{0,1} }; // 머리방향이 북, 동, 남, 서 일때 뒤로 뺴는 움직임

    bool able(int x, int y) { // 주어진 N과 M 범위 내에 존재하고, 이동하려는 위치가 벽이 아닌지 확인
        if ((x >= 0) && (x < N) && (y >= 0) && (y < M) && !map[x][y]) 
            return 1; // 이동 가능할경우 true
        else
            return 0; // 아닐경우 false
    }
    
    void dfs(int x, int y, int head, int answer) {
        if (!check[x][y]) { // 현재 위치가 청소되지않은 칸일경우
            check[x][y] = 1; // 청소했음을 체크하고
            ++answer; // 정답 +1
        }                         
        for (int a = 4; a > 0; --a) { // 반시계 방향으로 움직임
            int xx = x+mov[(head + a) % 4][0]; 
            int yy = y+mov[(head + a) % 4][1];
            if (able(xx,yy)) // 이동 가능한 위치고
                if (!check[xx][yy]) { // 청소하지 않았다면
                    dfs(xx, yy, (head + a+3) % 4, answer); // 탐색 실시
                    // head + a +3 으로 다음 head를 정해주는 이유는
                    // 이동방향을 알아내는 배열은 (head+a) 를 이용하지만,
                    // 실제 머리의 위치는 (head+a+3) 을 해야 일치함
                    // ex) head 가 0으로 북쪽을 위치할 경우 9시 방향부터 이동 가능한지 탐색을 실시함
                    // 실시했을 떄 ( head + a ) = (head=0 + a=4) 가 되는데, 
                    // 9시 방향으로 이동이 가능할 경우 head = 서쪽을 바라보는 3이 되어야함
                    // 그러므로 head+a != 머리 방향 이 되므로 head+a+3 을 해주어 
                    // 머리 방향과 이동방향이 같도록 설정
                    
                    return; // 이동 가능한곳을 찾았을 경우 for문 종료
                }
        }

        // 사방이 벽 혹은 이미 청소가 된 장소라면
        
        if (able(x + bak[head][0], y + bak[head][1])) { // 뒤로 이동가능하다면
            dfs(x + bak[head][0], y + bak[head][1], head, answer); // 이동
        }
        else { // 불가능하다면 
            cout << answer;
        }
    }
    int main() {
        ios::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        //freopen("Input.txt","r", stdin);
        cin >> N >> M;

        int x, y, head;
        cin >> x >> y >> head;

        for (int a = 0; a < N; ++a) {
            for (int b = 0; b < M; ++b) {
                cin >> map[a][b];
            }
        }

        dfs(x, y, head,0);
        return 0;

    }
    
    
