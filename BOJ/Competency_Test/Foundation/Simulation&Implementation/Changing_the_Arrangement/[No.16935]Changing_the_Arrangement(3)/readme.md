문제 사이트 : https://www.acmicpc.net/problem/16935

문제 설명 :

크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다. 연산은 총 6가지가 있다.

1번 연산은 배열을 상하 반전시키는 연산이다.

    1 6 2 9 8 4 → 4 2 9 3 1 8
    7 2 6 9 8 2 → 9 2 3 6 1 5
    1 8 3 4 2 9 → 7 4 6 2 3 1
    7 4 6 2 3 1 → 1 8 3 4 2 9
    9 2 3 6 1 5 → 7 2 6 9 8 2
    4 2 9 3 1 8 → 1 6 2 9 8 4
       <배열>       <연산 결과>
       
2번 연산은 배열을 좌우 반전시키는 연산이다.

    1 6 2 9 8 4 → 4 8 9 2 6 1
    7 2 6 9 8 2 → 2 8 9 6 2 7
    1 8 3 4 2 9 → 9 2 4 3 8 1
    7 4 6 2 3 1 → 1 3 2 6 4 7
    9 2 3 6 1 5 → 5 1 6 3 2 9
    4 2 9 3 1 8 → 8 1 3 9 2 4
       <배열>       <연산 결과>
       
3번 연산은 오른쪽으로 90도 회전시키는 연산이다.

    1 6 2 9 8 4 → 4 9 7 1 7 1
    7 2 6 9 8 2 → 2 2 4 8 2 6
    1 8 3 4 2 9 → 9 3 6 3 6 2
    7 4 6 2 3 1 → 3 6 2 4 9 9
    9 2 3 6 1 5 → 1 1 3 2 8 8
    4 2 9 3 1 8 → 8 5 1 9 2 4
       <배열>       <연산 결과>
       
4번 연산은 왼쪽으로 90도 회전시키는 연산이다.

    1 6 2 9 8 4 → 4 2 9 1 5 8
    7 2 6 9 8 2 → 8 8 2 3 1 1
    1 8 3 4 2 9 → 9 9 4 2 6 3
    7 4 6 2 3 1 → 2 6 3 6 3 9
    9 2 3 6 1 5 → 6 2 8 4 2 2
    4 2 9 3 1 8 → 1 7 1 7 9 4
       <배열>       <연산 결과>
       
5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.

    1 1 1 1 2 2 2 2
    1 1 1 1 2 2 2 2
    1 1 1 1 2 2 2 2
    4 4 4 4 3 3 3 3
    4 4 4 4 3 3 3 3
    4 4 4 4 3 3 3 3
    
5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.

    3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3
    9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2
    5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1
    2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7
    1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3
    4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8
         <배열>            <연산 결과>
         
6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 

2번을 1번으로 이동시키는 연산이다.

    3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2
    9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1
    5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3
    2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8
    1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8
    4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9
         <배열>            <연산 결과>
         
입력

    첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.

    둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.

    마지막 줄에는 수행해야 하는 연산이 주어진다. 
    
    연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다.

출력

    입력으로 주어진 배열에 R개의 연산을 순서대로 수행한 결과를 출력한다.

제한

    2 ≤ N, M ≤ 100
    1 ≤ R ≤ 1,000
    N, M은 짝수
    1 ≤ Aij ≤ 108
    
예제 입력 1 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    1
    
예제 출력 1 

    4 5 1 9 8 2 1 3
    1 3 2 8 7 9 2 1
    2 1 3 8 6 3 9 2
    5 9 2 1 9 6 1 8
    9 7 8 2 1 4 5 3
    3 2 6 3 1 2 9 7
    
예제 입력 2 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    2
    
예제 출력 2 

    7 9 2 1 3 6 2 3
    3 5 4 1 2 8 7 9
    8 1 6 9 1 2 9 5
    2 9 3 6 8 3 1 2
    1 2 9 7 8 2 3 1
    3 1 2 8 9 1 5 4
    
예제 입력 3 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    3
    
예제 출력 3 

    4 1 2 5 9 3
    5 3 1 9 7 2
    1 2 3 2 8 6
    9 8 8 1 2 3
    8 7 6 9 1 1
    2 9 3 6 4 2
    1 2 9 1 5 9
    3 1 2 8 3 7
    
예제 입력 4 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    4
    
예제 출력 4 

    7 3 8 2 1 3
    9 5 1 9 2 1
    2 4 6 3 9 2
    1 1 9 6 7 8
    3 2 1 8 8 9
    6 8 2 3 2 1
    2 7 9 1 3 5
    3 9 5 2 1 4
    
예제 입력 5 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    5
    
예제 출력 5 

    2 1 3 8 3 2 6 3
    1 3 2 8 9 7 8 2
    4 5 1 9 5 9 2 1
    6 3 9 2 1 2 9 7
    7 9 2 1 1 4 5 3
    8 2 1 3 9 6 1 8
예제 입력 6 

    6 8 1
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    6
    
예제 출력 6 

    1 2 9 7 6 3 9 2
    1 4 5 3 7 9 2 1
    9 6 1 8 8 2 1 3
    3 2 6 3 2 1 3 8
    9 7 8 2 1 3 2 8
    5 9 2 1 4 5 1 9
예제 입력 7 

    6 8 6
    3 2 6 3 1 2 9 7
    9 7 8 2 1 4 5 3
    5 9 2 1 9 6 1 8
    2 1 3 8 6 3 9 2
    1 3 2 8 7 9 2 1
    4 5 1 9 8 2 1 3
    1 2 3 4 5 6
    
예제 출력 7 

    3 1 2 8 9 1 5 4
    1 2 9 7 8 2 3 1
    2 9 3 6 8 3 1 2
    8 1 6 9 1 2 9 5
    3 5 4 1 2 8 7 9
    7 9 2 1 3 6 2 3
    
풀이 알고리즘

    1) 연산의 종류는 6가지이므로 각 동작은 나타내는 기능을 포함한 함수필요.
    
    2) (1, 2)는 추가적인 배열 없이, (1)은 1열 당 m/2번, (2)는 1행 당 n/2번씩 배열 원소의 위치를 바꾸는 연산을 진행하면 해결가능
    
    3) (3,4), (5,6) 추가적인 배열을 이용하여 연산이 진행 된 배열의 상태를 만든 후 기존의 배열에 덮어쓰는 작업 필요
   
[ 구 현 ]

1. 각 연산별 설명

  /* 사용변수 n = 행의 길이, m = 열의 길이, arr = 입력받은 배열, cpy = 임시 저장용 배열 */
  
  1) one : 상하반전
  
    void one() {
	    for (int b = 1; b <= m; ++b) { // 상하를 반전시키므로 한 열씩 연산 진행
        for (int a = 1; a <= n/2; ++a) { 
        // 행을 두개씩 묶어서 연산으 진행하므로 n/2번만큼만 진행 ex) (1,n) , (2,n-1) , (3,n-2) ...  
          int temp = arr[a][b]; // 위치를 바꾸는 연산이므로 임시저장 변수
          arr[a][b] = arr[n-a+1][b]; // a행의 b번쨰 원소와 n-a+1 번쨰 행의 원소끼리 위치를 바꾸기
          arr[n - a + 1][b] = temp; // 임시 저장한 변수 입력
        }
      }
      return;
    }
    
  2) two : 좌우반전


    void two() {
      for (int a = 1; a <= n; ++a) { // 좌우를 반전시키므로 한 행씩 연산 진행
          for (int b = 1; b <= m / 2; ++b) { 
          // one함수와 마찬가지로 연산을 반으로 나눠 진행하지만, 대상은 열이므로 m/2
              int temp = arr[a][b]; // 여기부터는 one과 비슷한 연산 실시
              arr[a][b] = arr[a][m-b+1];
              arr[a][m - b + 1] = temp;
          }
      }
      return;
    }
    
  3) three : -> 방향으로 90도 회전 연산

    void three() { 
          for (int a = 1; a <= n; ++a) { 
          // 90도 회전연산에서는 원소들끼리 1:1교환하는것이 아니라 계속 이동이 진행.
            for (int b = 1; b <= m; ++b) {
              cpy[b][n-a+1] = arr[a][b];
              /*오른쪽으로 90도 연산 진행시 특정 원소 [열]이 [행]으로 바뀌고, 
               [행]은 [열]의 위치를 찾는 재료로 사용!
               -> 90도 연산은 arr[a][b] 원소가 arr[b][n-a+1]의 위치로 가는 연산! */
              
            }
          }
          num = n;
          n = m;
          m = num;
          // 90도 회전 연산 후 행과 열의 길이가 서로 바뀌므로 n과 m의값을 바꿔주기
          for (int a = 1; a <= n; ++a) { // 완성된 cpy배열을 arr배열에 복사
            for (int b = 1; b <= m; ++b) {
              arr[a][b] = cpy[a][b];
            }
          }
        return;
    }

  4) four : <- 방향으로 90도 회전

    void four() { // three와 마찬가지로 임시배열을 완성시켜 본래 배열에 복사시키기
      for (int a = 1; a <= n; ++a) {
        for (int b = 1; b <= m; ++b) {
          cpy[m - b + 1][a] = arr[a][b];
          // four 함수에서는 원래 배열의 [행] 값이 [열] 값으로 바뀌고, [열]은 [행]을 만드는 연산에 사용
          // arr[a][b] -> arr[m-b+1][a]로 이동
        }
      }
      num = n;
      n = m;
      m = num;
      // 행과 열의 길이가 바뀌므로 n <-> m 을 해준 후, cpy배열을 arr배열에 복사
      for (int a = 1; a <= n; ++a) {
        for (int b = 1; b <= m; ++b) {
          arr[a][b] = cpy[a][b];
        }
      }
      return;
    }


5) five : 4등분 후 시계방향으로 위치바꾸기

![tempsnip](https://user-images.githubusercontent.com/57944215/144390794-b5b63e27-ff51-4bd7-a812-8dfa67390429.png)

/* 실제 사분면과 위치가 다르지만, 문제를 풀 떄 편하게 생각하기위해 위치에 따른 이름을 임의로 붙였습니다... */

위와 같은 표가 존재할 때, five연산은

    동작1. 1사분면 -> 2사분면
    동작2. 2사분면 -> 3사분면
    동작3. 3사분면 -> 4사분면
    동작4. 4사분면 -> 1사분면
    
으로 이동시키는 4가지 동작이 포함되어있었고, 그를 코드로 구현하였습니다.

        void five() {
        
          int m_jump = m / 2;  
          int n_jump = n / 2;
          // five 연산은 4등분으로 진행된 배열을 이용하여 연산이 진행되므로
          // n과 m을 반으로 나눈값을 미리 생성하여 사용
          
          for (int a = 1; a <= n_jump; ++a) { // 1사분면 -> 2사분면 이동
            for (int b = m_jump + 1; b <= m; ++b) {
              cpy[a + n_jump][b] = arr[a][b]; 
            }
          }
        // 동작 1은 1사분면에 존재하는 원소를 n/2만큼 행을 증가시키는 이동!

          for (int a = n_jump + 1; a <= n; ++a) { // 2사분면 -> 3사분면 이동 
            for (int b = m_jump + 1; b <= m; ++b) {
              cpy[a][b - m_jump] = arr[a][b];
            }
          }
        // 동작 2은 2사분면에 존재하는 원소를 m/2 만큼 열을 감소시키는 이동!

          for (int a = n_jump+1; a <= n; ++a) { // 3사분면 -> 4사분면 이동
            for (int b = 1; b <= m_jump; ++b) {
              cpy[a - n_jump][b] = arr[a][b];
            }
          }
        // 동작 3은 3사분면에 존재하는 원소를 n/2만큼 감소시키는 이동!

          for (int a = 1; a <= n_jump; ++a) { // 4사분면 -> 1사분면 이동
            for (int b = 1; b <= m_jump; ++b) {
              cpy[a][b + m_jump] = arr[a][b];
            }
          }
          // 동작 4는 4사분면에 존재하는 원소를 m/2만큼 증가시키는 이동!
          
          for (int a = 1; a <= n; ++a) {
            for (int b = 1; b <= m; ++b) {
              arr[a][b] = cpy[a][b];
            }
          }
          // 완성된 cpy배열을 arr배열에 복사
          
          return;
        }


  6) six : 4등분 후 반 시계 방향으로 위치바꾸기

  six의 4가지 동작
      
      동작1. 1사분면 -> 4사분면 이동
      동작2. 2사분면 -> 1사분면 이동
      동작3. 3사분면 -> 2사분면 이동
      동작4. 4사분면 -> 3사분면 이동
  
    void six() {
      int m_jump = m / 2;
      int n_jump = n / 2;
      for (int a = 1; a <= n_jump; ++a) { // 1사분면 -> 4사분면 이동
        for (int b = m_jump + 1; b <= m; ++b) {
          cpy[a][b-m_jump] = arr[a][b];
        }
      }
      // 동작 1은 1사분면에 위치한 원소를 m/2만큼 감소시키는 열 이동으로 4사분면으로 이동!

      for (int a = n_jump + 1; a <= n; ++a) { // 2사분면 -> 1사분면 이동 
        for (int b = m_jump + 1; b <= m; ++b) {
          cpy[a - n_jump][b] = arr[a][b];
        }
      }
      // 동작 2은 2사분면에 위치한 원소를 n/2만큼 감소시키는 행 이동으로 1사분면으로 이동!

      for (int a = n_jump + 1; a <= n; ++a) { // 3사분면 -> 2사분면 이동
        for (int b = 1; b <= m_jump; ++b) {
          cpy[a][b+m_jump] = arr[a][b];
        }
      }
      // 동작 3은 3사분면에 위치한 원소를 m/2만큼 증가시키는 열 이동으로 2사분면으로 이동!

      for (int a = 1; a <= n_jump; ++a) { // 4사분면 -> 3사분면 이동
        for (int b = 1; b <= m_jump; ++b) {
          cpy[a+n_jump][b] = arr[a][b];
        }
      }
      // 동작 4은 4사분면에 위치한 원소를 n/2만큼 증가시키는 행 이동으로 3사분면으로 이동!
      
      for (int a = 1; a <= n; ++a) {
        for (int b = 1; b <= m; ++b) {
          arr[a][b] = cpy[a][b];
        }
      }
      //arr배열에 복사
      return;
    }
    
 2. main 함수

        int main() {

          ios::sync_with_stdio(0);
          cin.tie(0);
          cout.tie(0);

        //	freopen("Input.txt", "r", stdin);

          cin >> n >> m >> k;
          
          for (int a = 1; a <= n; ++a){
            for (int b = 1; b <= m; ++b) {
              cin >> arr[a][b];
            }
          } // 입력값 arr배열에 저장
          
          int command = 0; // 명령은 1 ~ 6 의 정수로 나타내므로 int형 변수 command 선언
          while (k--) { // 명령어의 갯수는 k개, k가 0이 될떄까지 while 실행
            cin >> command;
            switch (command){ // if ~ else문보다 switch문으로 했을 때 동작속도가 12ms -> 8ms로 개선!
              case  1: // 각 케이스는 명령어를 의미 one ~ six까지 명령어 실행
                one();
                break;
              case 2:
                two();
                break;
              case 3:
                three();
                break;
              case 4:
                four();
                break;
              case 5:
                five();
                break;
              case 6:
                six();
                break;
              default :
                break;
            }
          }
          
          for (int a = 1; a <= n; ++a) {
            for (int b = 1; b <= m; ++b) {
              cout << arr[a][b] << " ";

            }
            cout << "\n";
          }
          // 모든 명령 종료 후 배열 출력
          
          return 0;
        }
    
3. 개선점?

  three() ~ six() 연산 진행 시 원래 배열로 복사하는 연산이 진행되는데, 
  
  이것대신 arr배열을 [2][101][101]로 선언 후, 현재 완성된 배열의 위치를 나타내는 전역변수 설정 후
  
  연산 진행시마다 arr[0] 과 arr[1] 을 오가며 
  
  작성을 반복하는 연산을 줄이면 메모리와 시간적으로 개선될듯해 보입니다.
  
