문제 사이트 : https://www.acmicpc.net/problem/15685

문제 설명 :

    드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다.

    시작 점
    시작 방향
    세대
    0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다.

![1](https://user-images.githubusercontent.com/57944215/183410393-fe3ac38e-1926-4d4d-b44d-f5d0166e74b0.png)


    1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다.
    
    끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.

![2](https://user-images.githubusercontent.com/57944215/183410421-3de12fbb-4f6c-488e-a3d2-3d256bef08e9.png)


    2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)

![3](https://user-images.githubusercontent.com/57944215/183410433-11b26eb8-5a2f-4543-94dd-91cbf0d0ac04.png)


    3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.

![4](https://user-images.githubusercontent.com/57944215/183410444-0c662d42-12ca-4039-89b5-6666674a307c.png)


    즉, K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다.

    크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 
    
    이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 
    
    격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.

입력

    첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다.
    
    둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. 
    
    x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)

    입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.

    방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.

    0: x좌표가 증가하는 방향 (→)
    1: y좌표가 감소하는 방향 (↑)
    2: x좌표가 감소하는 방향 (←)
    3: y좌표가 증가하는 방향 (↓)

출력

    첫째 줄에 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 출력한다.

예제 입력 1 

    3
    3 3 0 1
    4 2 1 3
    4 2 2 1

예제 출력 1 

    4

예제 입력 2 

    4
    3 3 0 1
    4 2 1 3
    4 2 2 1
    2 7 3 4

예제 출력 2 

    11

예제 입력 3 

    10
    5 5 0 0
    5 6 0 0
    5 7 0 0
    5 8 0 0
    5 9 0 0
    6 5 0 0
    6 6 0 0
    6 7 0 0
    6 8 0 0
    6 9 0 0

예제 출력 3 

    8

예제 입력 4 

    4
    50 50 0 10
    50 50 1 10
    50 50 2 10
    50 50 3 10

예제 출력 4 

    1992  
    
    
풀이 알고리즘

    진짜 오랫만에 돌아온 알고리즘 문제풀이 해설입니다. 6개월 전? 정도에 풀려고 도전했다가 해설을 봐도 이해를 못해서 놔버렸던 문제였는데요.
    
    이번에 우연히 문제를 다시보게되서 도전해서 풀어냈습니다!
    
    이 문제를 풀 떄 벽이 몇개 있었는데요
    
    1. 입력값으로 주어지는 x , y 좌표가 일반적인 방향이 아니다.
    
    문제의 설명에서는 x와 y를 반대로 주고, 설명을 반대로 하고있습니다. 그래서 입력을 y x 로 처리할지 x y 로 처리할지 순서에 대해 고민했었는데, 이해하기 쉬운
    
    x y 로 입력받고, 제가 알고리즘 구현을 할 때 반대로 생각하기로 했습니다.
    
    2. 드래곤 커브의 이동방향.
    
    처음에 이문제를 봤을 떄 x y 입력방법을 결정한 이후로 이해가 안되는 부분이였습니다. 문제 해설을 봐도 "왜 저걸 저렇게 움직이지?" 라는 생각밖에 안들었고, 
    
    코딩을 시작하지도 못하게 한 두번째 벽이였습니다.
    
    이번에 문제를 풀기위해 문제를 읽고 진행방향을 하나하나 써가면서 이전에 봣던 해설들을 설명이 떠오르면서 
    
    현재까지 드래곤 커브의 이동방향을 모아둔 배열의 값이 순서대로 [x y z k ] 라면 다음 드래곤 커브의 이동방향은 [k+1, z+1 , y+1 ,x+1]임을 이해했습니다.
    
    
    이 두개의 벽을 거치고 나니 코드 구현에는 큰 문제가 없었고, 중간중간 발생하는 에러를 잡아준 결과 문제를 통과할 수 있었습니다.
    
    알고리즘의 순서는 다음과 같습니다.
    
    
    1. 문제의 해결을 위해서는 다음과 같은 순서가 필요합니다.
    
        (1) 드래곤 커브를 완성시면서 방문했던 좌표를 모두 체크하여 방문 표시를 해둔다.
        
        (2) 드래곤 커브가 완성된 이후 2중for문을 사용하여 1 * 1 모양의 사각형을 확인하며 사각형의 갯수를 더하여 출력
        
    
    2. (1)의 구현을 위해서는 드래곤 커브의 이동방향을 예측해야하는데 드래곤 커브의 이동방향 규칙은 다음과 같습니다.
    
        1] 초기값으로 x y d g 가 주어졌다면, 드래곤 커브를 진행하기전 0세대 드래곤 커브를 완성하기 위해
        
         (x,y) 좌표와 d방향으로 이동을 진행한 드래곤 커브 0세대의 좌표를 방문표시해줍니다.
         
         그리고 d 를 이동방향을 저장하는 벡터에 저장하고 g번 반복하여 g세대의 드래곤커브를 만들기 시작합니다.
        
        2]  1~g세대의 드래곤커브 만들기가 시작되면 현재까지 저장된 이동방향 벡터를 배열의 끝부터 탐색을 시작합니다.
        
        그 이유는 드래곤 커브의 규칙때문입니다. 드래곤 커브가 2세대까지 진행되었다면 [ (x)0세대 이동 , (y)1세대 이동 , (z , k)2세대 이동 ] 과 같이 이동 방향을
        
        저장됩니다. 이동을 여러 변수가 아닌 하나의 변수로 바꾸면 [ x , x+1 , (x+1)+1, x+1 ] 과 같은 모양을 갖게되는데요, 이 모양을 규칙으로 만들면
        
        새로운 N 세대가 시작되면 N-1세대까지 저장된 방향벡터의 배열의 끝부터 시작까지 역으로 탐색하며 +1한 위치로 이동을 시작한다는 규칙이 나오게 됩니다.
        
        이 규칙을 사용하여 g세대까지 반복을 진행하면 g세대의 드래곤 커브까지 완성시키며 방문한 위치를 저장할 수 있습니다.
        
        
    3. (2)의 구현은 단순하게 2중 for문을 돌리면서 (a,b) ,(a,b+1), (a+1,b), (a+1,b+1) 이 모두 방문했던 위치라면 정답에 +1 시키는 동작을 하도록 구현하였습니다.
    
구 현

    #include <iostream>
    #include <queue>
    #include <vector>
    #include <algorithm>

    using namespace std;
    int T;
    int x, y, d, g;
    bool map[102][102];

    vector<int> arrow;
    int mov[4][2] = { {0,1},{-1,0},{0,-1},{1,0} };
    void run() {
        int size = arrow.size();

        for (int a = size-1; a >=0 ; --a) {
            int position = (arrow[a] + 1) % 4;
            x = x + mov[position][0];
            y = y + mov[position][1];
            map[x][y] = 1;
            arrow.push_back(position);
        }

    }
    void input() {
        cin >> T;
        for (int a = 0; a < T; ++a) {
            cin >> y >> x >> d >> g;

            map[x][y] = 1;
            x = x + mov[d][0];
            y = y + mov[d][1];
            map[x][y] = 1;
            arrow.push_back(d);
            while (g--) {
                run();
            }
            arrow.clear();

        }
    }

    bool find(int x, int y) {
        for (int a = 0; a < 2; ++a) {
            for (int b = 0; b < 2; ++b) {
                if (!map[x+a][y+b])
                    return 0;
            }
        }
        return 1;
    }
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        //freopen("input.txt", "r", stdin);
        input();
        int ans = 0;
        for (int a = 0; a < 101; ++a) {
            for (int b = 0; b < 101; ++b) {
                if (find(a,b))
                    ++ans;
            }
        }

        cout << ans;
        return 0;
    }
