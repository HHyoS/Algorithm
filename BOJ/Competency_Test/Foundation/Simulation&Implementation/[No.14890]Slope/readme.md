문제 사이트 : https://www.acmicpc.net/problem/14890

문제 설명 :

    크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. 

    오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.
    
    길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. 

    다음과 같은 N=6인 경우 지도를 살펴보자.

![123123123](https://user-images.githubusercontent.com/57944215/144838187-d24785c4-cb66-4c5a-948b-768598881ff6.png)

    이때, 길은 총 2N개가 있으며, 아래와 같다.

![2](https://user-images.githubusercontent.com/57944215/144838196-2f07951c-49ef-45a4-ae2c-a6ef2c11f970.png)


    길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 
    
    또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 
    
    또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.

    경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
    낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
    경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
    아래와 같은 경우에는 경사로를 놓을 수 없다.

    경사로를 놓은 곳에 또 경사로를 놓는 경우
    낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
    낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우

    경사로를 놓다가 범위를 벗어나는 경우
    L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.

![3](https://user-images.githubusercontent.com/57944215/144838212-a50bfe3c-3fd1-4b70-a339-9d2dd92356ba.png)


    경사로를 놓을 수 없는 경우는 아래와 같다.
    
![4](https://user-images.githubusercontent.com/57944215/144838218-8cdf8db8-8bc2-41ff-8af1-fe669e483e13.png)


    위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서,
    
    2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.

    가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 
    
    지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.

![5](https://user-images.githubusercontent.com/57944215/144838223-be4fdd1b-ceb5-405f-824a-3b98a6f95122.png)


    지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 
    
    둘째 줄부터 N개의 줄에 지도가 주어진다.
    
    각 칸의 높이는 10보다 작거나 같은 자연수이다.

출력

    첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.

예제 입력 1 

    6 2
    3 3 3 3 3 3
    2 3 3 3 3 3
    2 2 2 3 2 3
    1 1 1 2 2 2
    1 1 1 3 3 1
    1 1 2 3 3 2

예제 출력 1 

    3

예제 입력 2 

    6 2
    3 2 1 1 2 3
    3 2 2 1 2 3
    3 2 2 2 3 3
    3 3 3 3 3 3
    3 3 3 3 2 2
    3 3 3 3 2 2

예제 출력 2 

    7

예제 입력 3 

    6 3
    3 2 1 1 2 3
    3 2 2 1 2 3
    3 2 2 2 3 3
    3 3 3 3 3 3
    3 3 3 3 2 2
    3 3 3 3 2 2

예제 출력 3 

    3

예제 입력 4 

    6 1
    3 2 1 1 2 3
    3 2 2 1 2 3
    3 2 2 2 3 3
    3 3 3 3 3 3
    3 3 3 3 2 2
    3 3 3 3 2 2

예제 출력 4 

    11
    

풀이 알고리즘

    1. 이 문제에서 필요한 동작은 두가지입니다. (1) 내리막길 연산 (2) 오르막길 연산.
    2. 내리막길 연산은 같은경우에는 이전 배열들의 상태와 관계없이 앞으로 나아가면서 내리막길 연산이 가능한지 확인
    3, 오르막길 연산은 이전의 배열의 상태에 따라서 가능여부가 결정되므로 이전 배열들의 상태를 가지고 연산가능여부를 확인해야합니다.
    4. 내리막길 연산은 연속해서 발생할 수 있지만, 내리막길 -> 오르막길 연산이 연속해서 일어날 수 없고, 오르막길-> 내리막길 연산은 발생할 수 있습니다. 
    5. 그렇기 떄문에 같은 변수를 이용하여 위 문제를 해결할 수 없었고, 오르막길 연산이 가능한 케이스들을 분석하여 구현했씁니다.
    
[ 구 현 ]

    #include <iostream>
    #include <algorithm>
    #include <cstring>
    using namespace std;
    
    int n , l ; // 배열의 크기 n과 경사로의 길이 l
    
    int arr[100][100]; // 배열의 범위는 최대 1 <= n <= 100 이므로 int 100 * 100 배열 선언.

    bool x_down(int x, int y) { // x축에서 내려가는 내리막길 연산
      for (int a = 1; a < l; ++a) { // 매개변수로 들어오는 x,y값이 이미 한칸 전진한 값으로 입력되므로 for문의 범위는 1 ~ l-1까지
        if ((x + a >= n) || (arr[x][y] != arr[x+a][y])) //  방문한 위치가 범위를 벗어났거나, 비교대상인 arr[x][y]와 다르다면, 내리막길 연산 불가
          return 0; // x_down 함수를 종료하고, 내리막 불가표시로 0을 return
      }
      return 1; // for문을 무사히 마쳤다면, 내리막 연산이 가능하므로 1 return
    }
    bool y_down(int x, int y) { // y축에서 발생하는 내리막길 연산 ( x_down연산과 동일한 동작으로, x_down은 아래방향, y_down 은 오른쪽방향으로 진행되는 연산
      for (int a = 1; a < l; ++a) {
        if ((y + a >= n) || (arr[x][y] != arr[x][y + a]))
          return 0;
      }
      return 1;
    }

    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);

    //	freopen("Input.txt", "r", stdin);
      cin >> n >> l;
      for (int a = 0; a < n; ++a) {
        for (int b = 0; b < n; ++b) {
          cin >> arr[a][b]; // 배열정보 입력받기
        }
      }
      int answer = 0; // 정답을 저장할 변수
      for (int a = 0; a < n; ++a) { // -> 방향의 이동을 구현한 for문으로, 현재위치 (a,b)와 (a,b+1)을 비교하여 평지,오르막,내리막,이동 불가를 확인하며 for문을 진행합니다.
        int leng = 1; // leng은 오르막이 가능한지 확인할 떄 필요한 변수로, (a,b) -> (a,b+1) 를 비교하는 방식이기때문에 기본값으로 1을 세팅.
        for (int b = 0; b < n-1; ++b) {
          if (arr[a][b] == arr[a][b+1]) { // 평지라면, leng을 하나 더하여 여유도로길이를 추가.
            ++leng;
          }
          else if (arr[a][b] - arr[a][b+1] == 1){ // 다음 (a,b+1)이 (a,b)보다 1작은 내리막이라면
            if (y_down(a, b+1)) { // 내리막이 가능한지 체크
              b += l-1; // 가능하다면 다음에 탐색할 index는 b + l 이지만, for문은 마지막에서 ++b를 시키므로 b = b + l - 1 저장.
              leng = 0; // 내리막연산이 진행됬으므로 바로 오르막연산을 진행할 수 없음. leng = 0 저장.
            }
            else // 내리막 연산이 불가능 하다면, 현재 진행하고있는 (a,0) ~ (a,n)을 탐색하는 연산은 불가능.
              break; // 나가기
          }
          else if(arr[a][b] - arr[a][b+1] == -1){ // (a,b) 보다 (a,b+1)이 1 더 큰 오르막 연산이라면
            if (leng >= l) { // 경사로의 길이보다 여유도로의 길이가 더길다면
              leng = 1; // 오르막 연산을 진행했다 치고, leng의 길이를 1로 세팅(오르막 연산 이후 바로 오르막 연산 가능하기떄문)
            }
            else // 불가능하다면 for문 탈출
              break;
          }
          else { // 평지도 아니고, (a,b) 와 (a,b+1)의 차이가 1,-1 이 아니라면, 이동 불가능하므로
            break; // for문탈출
          }
          if (b >= n - 2) { // b의값이 탐색범위를 벗어났다면, 모든 탐색 index에 대해 이동이 가능하므로 answer ++
            ++answer;
          }
        }

      }
      for (int b = 0; b < n; ++b) { // ↓ 방향의 이동을 구현한 for문으로, 현재위치 (a,b)와 (a+1,b)을 비교하여 평지,오르막,내리막,이동 불가를 확인하며 for문을 진행합니다.
        int leng = 1; // 위에서 설명한 -> 방향 for문과 동일한 동작이므로 추가적으로 설명은 생략하겠습니다.
        ++num;
        for (int a = 0; a < n - 1; ++a) {
          if (arr[a][b] == arr[a+1][b]) {
            ++leng;
          }
          else if (arr[a][b] - arr[a+1][b] == 1) {
            if (x_down(a+1, b)) {
              a += l - 1;
              leng = 0;
            }
            else
              break;
          }
          else if (arr[a][b] - arr[a+1][b] == -1) {
            if (leng >= l) {
              leng = 1;
            }
            else
              break;
          }
          else {
            break;
          }
          if (a >= n - 2) {
            ++answer;
          }
        }

      }
      cout << answer;
      return 0;
    }
