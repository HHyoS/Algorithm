문제 사이트 : https://www.acmicpc.net/problem/1062

문제 설명 :

    남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다.
    
    그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다.
    
    김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 
    
    김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.

    남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 
    
    남극언어에 단어는 N개 밖에 없다고 가정한다. 
    
    학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 단어의 개수 N과 K가 주어진다. 
    
    N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다.
    
    둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 
    
    단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 
    
    모든 단어는 중복되지 않는다.

출력
    
    첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.

예제 입력 1 

    3 6
    antarctica
    antahellotica
    antacartica

예제 출력 1 

    2

예제 입력 2 

    2 3
    antaxxxxxxxtica
    antarctica

예제 출력 2 

    0

예제 입력 3 

    9 8
    antabtica
    antaxtica
    antadtica
    antaetica
    antaftica
    antagtica
    antahtica
    antajtica
    antaktica

예제 출력 3 

    3
    
풀이 알고리즘

    1. 읽어야하는 단어 n개와, 공부할 수 있는 알파뱃 갯수 K개가 주어졌을 때
    
    K개의 알파뱃을 잘 골라 최대한 많은 단어를 읽고, 그 갯수를 출력하는 문제였습니다.
    
    2. 이 문제에서 'a', 'c', 'i', 'n', 't'는 단어에 무조건 들어가는 단어이기 떄문에
    
    K값이 5 미만이라면 단어를 하나도 읽을 수 없습니다.
    
    3. K가 5 이상이라면 주어진 단어가 포함하고 있는  'a', 'c', 'i', 'n', 't' 를 제외한 알파뱃 중
    
    K-5개를 골라 읽을 수 있는 단어를 최대화 해야합니다.
    
    4. 문제의 풀이 알고리즘은 다음과 같습니다
    
      1) K값이 5미만이라면 0을출력하고 프로그램 종료.
      
      2) 아니라면 주어진 단어에서 'a', 'c', 'i', 'n', 't'를 제외한 알파뱃을 찾기.
      
      3) 찾은 알파뱃의 갯수를 n개라고 했을 때, 선택할 수 있는 알파뱃의 갯수는
      
      0 ~ K-5개를 골라야하고,(ex nC1, nC2, nC3 .... nC(K-5) 중 최대값을 찾아야 함)
      
      4) 고른 알파뱃과 주어진 단어들을 비교하여 배운 알파뱃들을 이용하여 단어를 만들수 있는지 확인하고,
      
      완전한 단어를 만들 수 있다면, 그 갯수를 더하여 최대값을 구하면 문제가 해결됩니다.
      
[ 구 현 ]

    #include <iostream>
    #include <string>
    #include <algorithm>
    #include <array>
    #include <vector>
    using namespace std;
    int N, K;
    bool alpa[26];
    string wd[50];
    bool ck[26];
    // a  = 97 z = 122
    int ct = 0;

    void dfs(int count, int idx) { // count는 골라야하는 갯수 ,idx 는 이전단계에서 탐색한 위치
      if (count == 0) { // 더이상 고를수 없다면
        int answer = 0; 
        int num;
        for (int a = 0; a < N; ++a) {
          bool check = 0; // 단어를 완성햇는지 확인하기 위한 변수
          for (int b = 4; b < wd[a].size()-4; ++b) {
            num = wd[a].at(b)-97; // a번쨰 입력받은 단어의 b번쨰 인덱스의 알파뱃
            if (!alpa[num]) { // 단어에 배운 알파뱃이 아닌 알파뱃이 존재한다면
              check = 1; // 완성 못했음을 체크하고
              break; // for문 탈출
            }
          }
          if (!check) // 단어를 완성햇다면
            ++answer; // 완성단어 1추가
        }
        if (answer > ct) // 완성된 단어 수가, 현재까지의 최대값보다 크다면
          ct = answer; // 그값은 최대값으로 저장
        return;
      }               
      else {
        ++idx; // 다음 탐색을 위한 인덱스 증가
        if ((idx >= 26) || (26-idx-count<= 0)) {
          return; // 인덱스가 증가햇을 때, 범위를 벗어나거나, 골라야하는 갯수보다 남은 단어가 적다면
        }

        if (ck[idx]) { // 현재 인덱스의 알파뱃이 단어에 포함되있는 알파뱃이라면
          alpa[idx] = 1; // 해당 알파뱃을 사용표시하고
          dfs(count - 1, idx); // 다음 탐색 시작
          alpa[idx] = 0; // 알파뱃 사용표시 해제
        }
        dfs(count, idx); // 현재 알파뱃의 사용유무 신경쓰지않고 다음단어로 스킵
      }
    }
    int main() {
      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
    //	freopen("Input.txt", "r", stdin);
      cin >> N >> K;
      if (K < 5) { // K값이 5 미만이라면 반드시 포함되어있는 a c i n t 를 배우지 못하므로 0츨력
        cout << "0";
        return 0;
      }
      else { // 아니라면
        K -= 5; // 선택해야하는 갯수를 5개 줄이고(a ,c , i, n t는 배워야하므로)
        alpa[97 -97] = 1; // a
        alpa[99 - 97] = 1; // c
        alpa[105 - 97] = 1; // i
        alpa[110 - 97] = 1; // n
        alpa[116 - 97] = 1; // t  알파뱃 다섯개는 반드시 배워야함
        int gat = 0;
        for (int a = 0; a < N; ++a) { // 입력받을 단어갯수 N
          cin >> wd[a];
          for (int b = 4; b < wd[a].size() - 4; ++b) { // 앞에서부터 4,뒤에서부터 4는 고정된 값이므로 생략
            int num = wd[a].at(b) - 97; //단어에 포함된 알파뱃 확인
            if(!ck[num]) { // 알파뱃이 아직 등록되지 않았다면
              ck[num] = 1; // 등록
            }
          }
        }

        ck[97 - 97] = 0; // a
        ck[99 - 97] = 0; // c
        ck[105 - 97] = 0; // i
        ck[110 - 97] = 0; // n
        ck[116 - 97] = 0; // t 고정된 알파뱃들은 불필요한 탐색이므로 체크해제
        dfs(0, 0); // 아무것도 선택하지 않았을 경우를 생각하여 한번 dfs돌려주고
    //		if (gat < K)
      //		K = gat-1;
        for (int b = 0; b < K; ++b) { // 0~K-5개를 선택하는 모든 경우의 수 확인
          for (int a = 0; a < 26; ++a) {
            if (ck[a]) { // a번째 알파뱃이 단어에 포함되어있는 알파뱃이라면
              alpa[a] = 1;
              dfs(b, a);
              alpa[a] = 0;
            }
          }
        }
      }
      cout << ct;
      return 0;
    }


      
      
    
