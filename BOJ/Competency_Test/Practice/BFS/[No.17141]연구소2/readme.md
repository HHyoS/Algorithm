문제 사이트 : https://www.acmicpc.net/problem/17141

문제 설명 :

    인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 
    
    바이러스를 유출하려고 한다. 

    승원이는 연구소의 특정 위치에 바이러스 M개를 놓을 것이고,

    승원이의 신호와 동시에 바이러스는 퍼지게 된다.

    연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며,

    정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 

    연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.

    일부 빈 칸은 바이러스를 놓을 수 있는 칸이다. 

    바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다.

    예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 

0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다.

    2 0 0 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 0 1 0 0
    0 1 0 0 0 0 0
    0 0 0 2 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 0 0 2

M = 3이고, 바이러스를 아래와 같이 놓은 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 바이러스를 놓은 위치는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.

    6 6 5 4 - - 2
    5 6 - 3 - 0 1
    4 - - 2 - 1 2
    3 - 2 1 2 2 3
    2 2 1 0 1 - -
    1 - 2 1 2 3 4
    0 - 3 2 3 4 5

시간이 최소가 되는 방법은 아래와 같고, 5초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.

    0 1 2 3 - - 2
    1 2 - 3 - 0 1
    2 - - 2 - 1 2
    3 - 2 1 2 2 3
    3 2 1 0 1 - -
    4 - 2 1 2 3 4
    5 - 3 2 3 4 5
   
연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.

입력

    첫째 줄에 연구소의 크기 N(5 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.

    둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 
    
    0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다. 
    
    2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.

출력

    연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 
    
    바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.

예제 입력 1 

    7 3
    2 0 0 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 0 1 0 0
    0 1 0 0 0 0 0
    0 0 0 2 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 0 0 2

예제 출력 1 

    5
    
예제 입력 2 

    7 3
    2 0 2 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 2 1 0 0
    2 1 0 0 0 0 2
    0 0 0 2 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 2 0 2

예제 출력 2 


    5


예제 입력 3 

    7 4
    2 0 2 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 2 1 0 0
    2 1 0 0 0 0 2
    0 0 0 2 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 2 0 2

예제 출력 3 

    4

예제 입력 4 

    7 5
    2 0 2 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 2 1 0 0
    2 1 0 0 0 0 2
    0 0 0 2 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 2 0 2

예제 출력 4 

    3

예제 입력 5 

    7 3
    2 0 2 0 1 1 0
    0 0 1 0 1 0 0
    0 1 1 1 1 0 0
    2 1 0 0 0 0 2
    1 0 0 0 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 2 0 2
    
예제 출력 5 

    7

예제 입력 6 

    7 2
    2 0 2 0 1 1 0
    0 0 1 0 1 0 0
    0 1 1 1 1 0 0
    2 1 0 0 0 0 2
    1 0 0 0 0 1 1
    0 1 0 0 0 0 0
    2 1 0 0 2 0 2
    
예제 출력 6 

    -1

예제 입력 7 

    5 1
    2 2 2 1 1
    2 1 1 1 1
    2 1 1 1 1
    2 1 1 1 1
    2 2 2 1 1
    
예제 출력 7 

    4 
 
 퓰이 알고리즘
 
    N*N 크기의 연구소에서 M개의 바이러스를 퍼트려 최단시간내에 
    
    연구소의 0값을 바이러스로 감염시키고 시간을 출력하는 문제였습니다.
    
    문제의 입력으로는 연구소의 크기 N과 놓아야하는 바이러스의 갯수 M, 연구소의 정보가 입력됩니다.
    
    연구소의 입력은 0 = 빈공간, 1 = 벽 , 2 = 바이러스를 놓을 수 있는 공간입니다.
    
    입력을 받으며 0의 갯수를 저장해 빈공간의 갯수를 사용할 수 있도록 저장하였습니다.
    
    또한 이 문제에서 2가 의미하는 정보는 바이러스를 놓을 수 있는 공간이라는 의미일 뿐,
    
    바이러스가 퍼질 수 없는 곳이 아니라는 것 입니다.
    
    2는 바이러스를 놓을 수 있는 공간이지만 바이러스를 놓지 않을경우 0과 
    
    같이 바이러스가 퍼질 수 있는 공간이 될 수 있기떄문에, 저는 입력으로 2가 들어왔을 때, 
    
    virus라는 vector배열에 해당 위치를 저장하여 바이러스를 놓을 수 있는 장소에 대한 정보를 
    
    저장하고, 연구소의 정보에는 2가 아닌 0을 저장하여 바이러스가 퍼질 수 있는 공간으로 
    
    설정하였고, 빈 공간의 갯수에 2의 갯수, 즉 바이러스를 놓을 수 있는 
    
    공간의 갯수를 K개라 햇을 떄, K-M개 만큼의 공간. 바이러스를 놓을 수 있지만 
    
    놓지 않을 공간 또한 빈 공간의 갯수에 추가시켜 놓았습니다.
    
    그 이후 K 개중 M개의 장소를 정하는 과정을 dfs탐색을 통해 정하였고, 
    
    해당 위치들을 새로운 벡터에 저장하였습니다.
    
    그 이후 M개의 선택이 끝나면, M개의 위치를 담은 queue를 만들어 bfs탐색을 진행하고
    
    bfs탐색을 하며 감염시킨 공간의 갯수를 세고, bfs과정에서 빈공간의 갯수를 저장해놓은 변수와
    
    같은 값을 가지게 되면 해당 횟수를 현재까지의 최단시간과 비교하여 최단시간을 갱신해나갔습니다.
    
    만약 bfs내에서 빈공간의 갯수를 만족하지 못했을 경우, 21e8 이라는 매우 큰 수를 반환하여 찾지못했음
    
    을 표시했습니다.
    
    모든 탐색이 종료된 이후 최단시간이 21e8 이라면 다 감염시킬 수 없으므로 -1 출력
    
    아닐경우 최단시간을 출력하여 무제를 해결하였습니다.
    


구 현

	#include<iostream>
	#include<string>
	#include<algorithm>
	#include<queue>

	using namespace std;

	struct Node {
		int x;
		int y;
	};


	int N, M;
	int map[51][51]; // 연구소 정보
	vector<Node> virus; // 바이러스 놓을 수 있는 곳 위치 저장벡터
	int room_counter = 0; // 빈공간 갯수세기
	vector<Node> choice; // M개 선택한 바이러스 위치 저장
	int mov[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };
	int mini = 21e8; // 최단시간을 기록하므로 매우 큰 수를 집어넣어서 최단시간이 
			//생겻을 경우 갱신 되로록

	int bfs() {
		if (room_counter == 0) // 만약 빈공간의 갯수가 0이라면 0초만에 모두 감염된 상태
			return 0;

		queue<Node> que;
		bool checker[51][51] = {}; // 방문한 위치인지 확인
		for (int a = 0; a < M; ++a) {
			que.push(choice[a]); // M개 선택한 바이러스 놓을곳을 que에 복사하고
			checker[choice[a].x][choice[a].y] = 1; // 해당 위치는 미리 방문표시
		}
		int cnt = 1;  // 걸린 시간 변수
		int rooms = 0; // 감염시킨 공간 세는 변수
		while (!que.empty()) {
			int size = que.size();
			for (int a = 0; a < size; ++a) {
				int x = que.front().x;
				int y = que.front().y;
				que.pop();

				for (int b = 0; b < 4; ++b) {
					int xx = x + mov[b][0];
					int yy = y + mov[b][1];

					if (xx >= 0 && xx < N && yy >= 0 && yy < N && map[xx][yy] == 0 && !checker[xx][yy]) {
						++rooms;
						if (rooms == room_counter) // 미리 계산해놓은 빈공간의 갯수와 같다면
							return cnt; // 시간 return

						checker[xx][yy] = 1;
						que.push({ xx,yy });
					}
				}
			}
			++cnt;
		}
		return 21e8; // bfs탐색 완료후에도 빈공간만큼 채우지 못햇다면 못찾음 표시
	}
	void dfs(int idx, int count) {
		if (count == M) { // 바이러스 놓을 공간 M개 선택 했다면
			int temp =bfs(); // 해당 위치들로 bfs탐색을 돌리고
			if (temp < mini) { // 거기서 나온 최단시간이 현재까지 구한 최단시간보다 짧다면
				mini = temp; // 최단시간 갱신
			}
			return; // dfs탐색 종료
		}

	  // 만약 남은 바이러스 공간으로는 M개를 다 선택못한다면 dfs종료
		if (virus.size() - idx - 1 + count < M) return;  

		for (int a = idx + 1; a < virus.size(); ++a) {
			choice.push_back(virus[a]); // 현재 위치를 바이러스 놓을 공간에 추가시키고
			dfs(a, count + 1); // dfs돌리고
			choice.pop_back(); // pop해서 새로운 위치 저장준비
		}
	}
	void solve() {

		for (int a = 0; a < virus.size(); ++a) { // M개의 바이러스 공간선택하기 시작부분
			choice.push_back(virus[a]);
			dfs(a, 1);
			choice.pop_back();
		}
	}


	void input() {
		cin >> N >> M;

		for (int a = 0; a < N; ++a) {
			for (int b = 0; b < N; ++b) {
				cin >> map[a][b];
				if (map[a][b] == 0) {
					++room_counter; // 빈공간 갯수세기
				}
				else if (map[a][b] == 2) {
					map[a][b] = 0; // 바이러스 놓을 수 있는 곳은 빈공간과 같다!
					virus.push_back({ a,b }); // 해당 위치를 바이러스 벡터에 추가
				}
			}
		}


	  //전체 빈 공간은 0으로 입력된 위치 + 전체 바이러스 놓을 수 있는 공간 - 실제로 놓을 공간갯수
		room_counter = room_counter + virus.size() - M; 
	}

	int main()
	{
		ios::sync_with_stdio(false);

		cin.tie(NULL);
		cout.tie(NULL);

		input();
		solve();
		if (mini == 21e8) // 빈 공간을 전부 채울 수 없다면
			cout << -1; // -1 반환
		else
			cout << mini; // 아니면 최단시간 출력
		return 0;

	}




    
    
