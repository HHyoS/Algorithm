문제 사이트 : https://www.acmicpc.net/submit/16198/35884664

문제 설명 :

    N개의 에너지 구슬이 일렬로 놓여져 있고, 에너지 구슬을 이용해서 에너지를 모으려고 한다.
    i번째 에너지 구슬의 무게는 Wi이고, 에너지를 모으는 방법은 다음과 같으며, 반복해서 사용할 수 있다.
    에너지 구슬 하나를 고른다. 
    고른 에너지 구슬의 번호를 x라고 한다. 
    단, 첫 번째와 마지막 에너지 구슬은 고를 수 없다.
    x번째 에너지 구슬을 제거한다.
    Wx-1 × Wx+1의 에너지를 모을 수 있다.
    N을 1 감소시키고, 에너지 구슬을 1번부터 N번까지로 다시 번호를 매긴다. 
    번호는 첫 구슬이 1번, 다음 구슬이 2번, ... 과 같이 매겨야 한다.
    N과 에너지 구슬의 무게가 주어졌을 때, 
    모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 에너지 구슬의 개수 N(3 ≤ N ≤ 10)이 주어진다.

    둘째 줄에는 에너지 구슬의 무게 W1, W2, ..., WN을 공백으로 구분해 주어진다. (1 ≤ Wi ≤ 1,000)

출력

    첫째 줄에 모을 수 있는 에너지의 최댓값을 출력한다.

예제 입력 1 

    4
    1 2 3 4

예제 출력 1 

    12

예제 입력 2 

    5
    100 2 1 3 100

예제 출력 2 

    10400

예제 입력 3 

    7
    2 2 7 6 90 5 9

예제 출력 3 

    1818

예제 입력 4 

    10
    1 1 1 1 1 1 1 1 1 1

예제 출력 4 

    8
    
풀이 알고리즘

    1. 구슬의 최대값은 10개이고, 모든 구슬이 값이 1,000 이라고 가정해도 int 범위 내에서 답이 나올수있다!
    2. W(x-1) * W(x+1) 연산 중 가장 큰값을 먼저 사용한다고해도 그것이 최대값임을 보장하지 않으므로, 모든 경우의수 탐색
    3. 탐색 과정에서 연산을 진행한 횟수를 더하여 처음과 ㄱ튼만 남는 횟수가 n-2 일떄 재귀 종료.

[ 구 현 ]

1. 사용 전역변수 

        int n;
        int arr[11];
        bool check[11];
        int answer = 0;
    
   1) n = 입력받는 값으로 구슬이 갯수를 의미.
   2) arr = 구슬의 무게를 저장하는 배열. 0번 배열을 사용하지 않을 계획이여서 범위를 11로 설정.
   3) check = 해당 위치의 구슬을 제거했는지 확인하기 위한 배열.
   4) answer = 정답을 저장하는 변수로, 재귀를 반복하며 횟수가 n-2 일때 비교되는 값.

2. main 함수

        int main() {

          ios::sync_with_stdio(0);
          cin.tie(0);
          cout.tie(0);

        //	freopen("Input.txt", "r", stdin);
          cin >> n; // 구슬 갯수를 입력받고.
          for (int a = 1; a <= n; ++a) {
            cin >> arr[a]; // 구슬의 무게 저장 후
          }
          for (int a = 2; a < n; ++a) { // 구슬 선택가능 위치는 2 ~ n-1까지.
            int sum; // 선택한 a 기준 좌, 우 구슬의 곱을 넣을 변수
            check[a] = 1; // a에 방문표시 후 
            sum = arr[a - 1] * arr[a + 1]; // 좌, 우의 구슬 무게 곱한 후
            dfs(1,sum); // dfs 시작. a를 고른상태로 시작하므로 횟수는 1, 초기값은 sum
            check[a] = 0; // 다음 재귀를 위한 방문해제.

          }
          cout << answer; // 정답 출력
          return 0;
        }
        
3. DFS 함수

        void dfs(int count, int sum) { // count는 구슬 제거 횟수, sum은 지금까지 구슬을 제거하며 얻은 총 합.
          if (count == (n-2)) { // 횟수가 처음과 끝 구슬을 제외한 모든 구슬을 제거한 상황이라면
            if (sum > answer) // sum과 answer을 비교한 후 
              answer = sum; // sum이 더 크다면 sum을 answer로!
            return; // 재귀의 탈출!
          }

          int left = 0, right = 0; // 고른 구슬 기준으로 제거되지 않은 좌, 우의 구슬값을 저장할 변수
          for (int a = 2; a < n; ++a) {
            if (check[a]) // a위치의 구슬이 제거되었다면~
              continue; // for문의 끝으로
            check[a] = 1; // 아닐경우 a 구슬을 제거표시하고
            for (int b = a-1; b > 0; --b) { // 제거되지않은 왼쪽 구슬위치 탐색
              if (!check[b]) { // 제거되지 않은 구슬을 찾았다면 
                left = arr[b]; // left에 해당값 저장 후
                break; // for문 탈출
              }
            }
            for (int b = a + 1; b <= n; ++b) { // 제거되지않은 오른쪽 구슬위치 탐색
              if (!check[b]) { // 제거되지 않은 구슬을 찾았다면~
                right = arr[b]; // right에 해당 값 저장 후
                break; // for문 탈출
              }
            }
            dfs(count + 1, sum + (left*right)); // 찾은 값을 바탕으로 dfs탐색을 시작하고, 횟수를 1증가, sum 위치에는 기존의 sum + (구슬제거로 얻은 값) 을 매개변수로 넘김

            check[a] = 0; // 다음 재귀를 위한 방문표시 
          }
        }
