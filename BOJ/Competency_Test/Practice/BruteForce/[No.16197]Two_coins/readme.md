문제 사이트 : https://www.acmicpc.net/problem/16197

문제 설명 : 

    N×M 크기의 보드와 4개의 버튼으로 이루어진 게임이 있다.
    
    보드는 1×1크기의 정사각형 칸으로 나누어져 있고, 
    
    각각의 칸은 비어있거나, 벽이다.
    
    두 개의 빈 칸에는 동전이 하나씩 놓여져 있고, 두 동전의 위치는 다르다.

    버튼은 "왼쪽", "오른쪽", "위", "아래"와 같이 4가지가 있다. 
    
    버튼을 누르면 두 동전이 버튼에 쓰여 있는 방향으로 동시에 이동하게 된다.
    
    [ 동 작 ]
    
    1. 동전이 이동하려는 칸이 벽이면, 동전은 이동하지 않는다.
    2. 동전이 이동하려는 방향에 칸이 없으면 동전은 보드 바깥으로 떨어진다.
    3. 그 외의 경우에는 이동하려는 방향으로 한 칸 이동한다.
    4. 이동하려는 칸에 동전이 있는 경우에도 한 칸 이동한다.
    5. 두 동전 중 하나만 보드에서 떨어뜨리기 위해 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 20)

    둘째 줄부터 N개의 줄에는 보드의 상태가 주어진다.

    o: 동전
    .: 빈 칸
    #: 벽
    
    동전의 개수는 항상 2개이다.

출력

    첫째 줄에 두 동전 중 하나만 보드에서 떨어뜨리기 위해 눌러야 하는 버튼의 최소 횟수를 출력한다. 
    
    만약, 두 동전을 떨어뜨릴 수 없거나, 버튼을 10번보다 많이 눌러야 한다면, -1을 출력한다.

예제 입력 1 

    1 2
    oo

예제 출력 1

    1

예제 입력 2 

    6 2
    .#
    .#
    .#
    o#
    o#
    ##

예제 출력 2 

    4

예제 입력 3 

    6 2
    ..
    ..
    ..
    o#
    o#
    ##
    예제 출력 3 
    3
    예제 입력 4 
    5 3
    ###
    .o.
    ###
    .o.
    ###

예제 출력 4 

    -1

예제 입력 5 

    5 3
    ###
    .o.
    #.#
    .o.
    ###

예제 출력 5 

    3
    
풀이 알고리즘

    전형적인 지도이동 문제 + BFS탐색을 통해 가장 빠른방법을 찾는 문제였습니다.
    
    하지만 움직이는 대상이 하나가 아닌 두개의 동전이였기 때문에, 동전을 어떻게 관리할지를
    
    결정하는것이 문제였습니다.
    
    여러가지 방법을 시도해 보면서 두개의 동전을 한번에 관리하는것보다,
    
    두개의 변수를 이용하여 따로 구현하는 방법이 직관적이 더 편리하여 사용하게 되었습니다.
    
    이 문제에서 동전의 동작은 크게 세가지 입니다.
    
    1. 움직이는 방향에 벽이 있으면 멈춘다.
    2. 움직이는 방향이 보드 밖이라면 떨어진다.
    3. 움직이는 방향이 벽도 아니고 보드 밖도 아니라면 움직인다.
    
    이 세가지를 더 자세히 나누어보면
    
    첫번째 조건은 [ 멈춘다 ] -> 움직이기 전의 상태로 돌아간다 로 볼 수 있고.
    두번쨰 조건은 [ 떨어진다 ] -> 하나가 떨어지면 탐색이 종료되고, 두개가 동시에 떨어지면 해당 케이스는 종료
    세번째 조건은 조건 그대로인 벽과 떨어지는 위치가 아니라면 계속 움직인다. 입니다.
    
    그리고 동작이 진행하면서 두 동전이, 이전에 존재했던 위치를 다시 움직이는 경우가 있습니다.
    
    ex) 1회 이동 { coin_1(a,b) coin_2(a',b') } -> 5회 이동 { coin_1(a,b) coin_2(a',b') }
    
    이러한 케이스는 무의미한 동작을 발생시키므로, 두 동전이 방문을 기록하는 bool 배열을 선언하여 관리하여
    
    불필요한 메모리 사용과 반복문의 사용을 줄였습니다.

[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    #include <utility>

    using namespace std;
    int N, M;            
    char board[22][22]; // 보드판
    queue<pair<int,int>> coin_1; // 첫번째 동전의 움직임을 저장하는 변수 coin_1
    queue<pair<int,int>> coin_2; // 두번째 동전의 움직임을 저장하는 변수 coin_2
    int mov[4][2] = { {1,0},{-1,0},{0,1},{0,-1} }; // 동전이 할 수 있는 동작 4가지( 상, 하, 우, 좌)를 의미하는 mov배열
    bool check[21][21][21][21]; // 두개의 동전이 동시에 존재했던 위치를 기록하고, 반복된 위치에서의 탐색을 줄이기 위한 check 배열

    bool two_out(pair<int, int> coin_1, pair<int, int>coin_2) { // 탐색이 불필요한 조건을 체크하는 함수 two_out
      if ((coin_1.first == coin_2.first) && (coin_1.second == coin_2.second)) // 첫번째 out조건, 두 개의 동전이 같은위치에 존재할경우
        return 1; // 두 개의 동전이 같은 위치에 존재할 경우, 어떻게 움직여도 동시에 떨어지거나, 동시에 보드판 안에 남아있으므로 탐색하지 않도록 1을 return
        
      if ((board[coin_1.first][coin_1.second] == '-') && (board[coin_2.first][coin_2.second] == '-')) // 두 개의 동전이 동시에 보드판에서 나가면 문제의 풀이조건이 안되므로
        return 1; // 탐색하지 않도록 1 return
        
      return 0; // 두 조건을 모두 만족하지 않을경우, 탐색에 적절한 위치이므로 0 return
    }
    
    int main() {
      /*ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);*/

      //freopen("Input.txt", "r", stdin);
      scanf("%d %d ", &N, &M);
      int x[2], y[2]; // 처음 동전의 위치를 저장하는 배열 x 와 y
      
      int idx = 0;
      for (int a = 0; a <= N+1; ++a) {
        for (int b = 0; b <= M +1; ++b) {
          board[a][b] = '-'; // 판 전체를 문자열 ' - ' 로 채워놓고, 이 후 보드의 정보가 입력되면 
          // 떨어지는 위치를 나타내는 문자열 ' - ' 가 N * M 크기의 보드판을 감싸게됌
        } 
      }
      for (int a = 1; a <= N; ++a) {
        for (int b = 1; b <= M-1; ++b) {
          scanf("%c", &board[a][b]); // 보드의 정보를 입력받고
          if (board[a][b] == 'o') { // 해당 위치가 동전이라면
            x[idx] = a; // 동전 위치기록
            y[idx++] = b; // 동전은 두개이므로 idx를 하나 증가시켜서 x[1] . y[1]에도 값이 입력될 수 있도록함.
          }

        }
        scanf("%c ", &board[a][M]); // scanf로 입력받기 때문에 개행문자 처리를 위해 줄의 마지막 문자는 따로처리
        if (board[a][M] == 'o') {
          x[idx] = a;
          y[idx++] = M;
        }
      }
      
    /*	for (int a = 0; a <= N + 1; ++a) { 보드판의 정보가 제대로 입력되었는지 확인하기 위한 2중 for문
        for (int b = 0; b <= M + 1; ++b) {
          printf("%c ", board[a][b]);
        }
        printf("\n");
      } */
      
      coin_1.push({ x[0],y[0] });
      coin_2.push({ x[1],y[1] });
      // 두 동전의 초기정보 push
      
      check[x[0]][y[0]][x[1]][y[1]] = 1; // 초기 동전의 위치 check배열에 추가하여 재방문 방지
      
      int count = 1; // 동전의 초기위치에서는 문제의 해결조건이 안생기므로 무조건 1이상이 답으로 나옴
      // 그러므로 count를 1부터 시작하여 이동 실시
      
      
      while (count < 11) { 
      // 이동횟수가 10회까지는 정답으로 처리되지만, 11회부터는 -1을 출력해야하는 조건이므로 count < 11 일때 while문 동작
        int size = coin_1.size(); // coin_1과 coin_2의 크기는 같으므로 coin_1의 크기만큼 반복
        for (int a = 0; a < size; ++a) {
        
          int xx_1 = coin_1.front().first;
          int yy_1 = coin_1.front().second; 

          int xx_2 = coin_2.front().first;
          int yy_2 = coin_2.front().second;
          
          /* 두 개의 동전위치를 queue에서 뽑아낸 뒤, pop하여 해당 정보 삭제 */
          
          coin_1.pop();
          coin_2.pop();

          for (int b = 0; b < 4; ++b) { // 동전의 동작 4가지
            int xxx_1 = xx_1 + mov[b][0];
            int yyy_1 = yy_1 + mov[b][1];

            int xxx_2 = xx_2 + mov[b][0];
            int yyy_2 = yy_2 + mov[b][1];

            if (two_out({ xxx_1,yyy_1 }, { xxx_2,yyy_2 })) // 현재 이동이 게임 진행이 가능한 움직임이 아닐경우
              continue; // for문 끝으로

            if (board[xxx_1][yyy_1] == '#') { // 첫번째 동전의 이동위치에 벽이 있다면
              xxx_1 = xx_1;
              yyy_1 = yy_1; // 이동하지 않음 위치 저장
            }
            else { // 벽이 아니라
              if (board[xxx_1][yyy_1] == '-') { // 떨어지는 위치라면
                printf("%d", count); // 동전이 하나만 떨어지는 조건을 충족했으므로 답을 출력하고
                return 0; // 프로그램 종료
              }
          
            }
            if (board[xxx_2][yyy_2] == '#') { // 위의 if ~ else 문과 같은 동작
              xxx_2 = xx_2;
              yyy_2 = yy_2;
            }
            else {
              if (board[xxx_2][yyy_2] == '-') {
                printf("%d", count);
                return 0;
              }
            }
            
            if (!check[xxx_1][yyy_1][xxx_2][yyy_2]) { // 현재 주어진 위치기 이전에 방문했던 위치가 아니라면
              coin_1.push({ xxx_1,yyy_1 }); // queue에 push하고
              coin_2.push({ xxx_2,yyy_2 });
              check[xxx_1][yyy_1][xxx_2][yyy_2] = 1; // 방문표시
            }
          }

        }
        ++count;
      }
      printf("-1"); // 이 문장까지 실행됬다는 것은 10회 안에 동전을 하나만 떨어트릴 수 있는
      // 방법이 존재하지 않는것이므로 -1
      return 0;
    }


    
    
