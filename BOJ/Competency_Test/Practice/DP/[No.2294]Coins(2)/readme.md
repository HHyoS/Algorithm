문제 사이트 : https://www.acmicpc.net/problem/2294

문제 설명 : n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.

출력

첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

예제 입력 1 

	3 15
	1
	5
	12
	
예제 출력 1 

	3


코드

	#include <iostream>
	#include <algorithm>
	using namespace std;
	int coin[101];
	int dp[100001];
	int main() {
		int n, k;
		cin >> n >> k;
		for (int i = 1; i <= n; i++) cin >> coin[i];
		fill(dp, dp+100001, 100001);
		dp[0] = 0;
		for (int i = 1; i <= n; i++){
			for (int j = coin[i]; j <= k; j++)
				dp[j] = min(dp[j], dp[j - coin[i]] + 1);
		}
		dp[k] = (dp[k] == 100001) ? -1 : dp[k];
		cout << dp[k] << endl;
		return 0;
	}




풀이

풀이의 순서는 다음과 같습니다.

	1. dp로 해결한 가능한 문제이므로 점화식과 메모리제이션을 이용하여 알고리즘 설계.
	2. 동전의 가치는 100,000보다 작거나 같은 자연수.
	3. n가지 동전 최소한의 갯수만을 사용해서 그 가치의 합이 k가 되도록하고, 불가능할경우 -1 출력

사용되는 동전이 3가지로 가치가 1, 2, 3 인 배열 coin[1], coin[2], coin[3]일때 점화식을 세워보면

	k 가 1 최소값 = coin[1] 사용 = 1 coin[2] 사용 = 0 coin[3] 사용 = 0
	k 가 2 최소값 = coin[1] 사용 = 0 coin[2] 사용 = 1 coin[3] 사용 = 0
	k 가 3 최소값 = coin[1] 사용 = 0 coin[2] 사용 = 0 coin[3] 사용 = 1
	k 가 4 최소값 = coin[1] 사용 = 1 coin[2] 사용 = 0 coin[3] 사용 = 1 or coin[1] 사용 = 0 coin[2] 사용 = 2 coin[3] 사용 = 0
	...
	
이 점화식을 이어나가면 dp[x] = min(dp[x], dp[x - coin[y]+1])로 더 작은값이 dp값에 저장되는 점화식이 완성됩니다.

