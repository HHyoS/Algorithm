문제 사이트 : https://www.acmicpc.net/problem/2293

문제 설명 :

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

출력

첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

예제 입력 1 

	3 10
	1
	2
	5
	
예제 출력 1 

	10

코드

	#include <iostream>
	using namespace std;
	int coin[101];
	int dp[10001];
	int main() {
		int n, k;
		scanf("%d %d",&n,&k);
		for (int a = 1; a <= n; ++a)
	    scanf("%d",&coin[a]);
		dp[0] = 1;
		for (int a = 1; a <= n; ++a) {
			for (int b = 1; b <= k; ++b) {
				if (b - coin[a] >= 0)
					dp[b] += dp[b - coin[a]];
			}
		}
		printf("%d",dp[k]);
		return 0;
	}

해설

입력값 n 이 주어졌을 떄 동전을 사용하여 동전의 순서를 만들어 낼 때, 마지막에 올 수 있는 동전의 종류는 n 가지 입니다.

그래서 특정 수 k가 주어졌을 떄, dp[k]를 구하기 위해서는 dp[k - coin[n] ] + dp[k - coin[n-1]] + .... + dp[k - coin[0]] 의 규칙이 발생하게 되고, 이를 바탕으로 점화식을 2중 for문을 이용하여

코드를 작성하면 

	for (int a = 1; a <= n; ++a) {
			for (int b = 1; b <= k; ++b) {
				if (b - coin[a] >= 0)
					dp[b] += dp[b - coin[a]];
			}
		}
		
과 같이 작성됩니다.

입력값이 작은값부터 주어지는 것이 아니기 때문에 if문을 사용하였고, sort함수를 이용하여 정렬한다면 if문을 제거할 수 있겟지만 소규모의 프로그램이기때문에 sort함수없이 if문으로 대체하여 코드를 작성하였습니다.
