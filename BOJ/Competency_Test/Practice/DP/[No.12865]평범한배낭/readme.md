문제 사이트 : https://www.acmicpc.net/problem/12865

개발 환경 : Visual Studio 2019

설 명 :

    이 문제는 아주 평범한 배낭에 관한 문제이다.

    한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

    준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

입력

    첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

    입력으로 주어지는 모든 수는 정수이다.

출력

    한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

예제 입력 1 

    4 7
    6 13
    4 8
    3 6
    5 12

예제 출력 1 

    14
    
풀 이

    주어진 조건에서 최대의 가치를 갖는 물품 조합을 찾아내는 문제였습니다.
    
    이 문제의 해결을 위해서 완전탐색 방식이나 dfs 방식을 사용하여 풀어보려고 했지만
    
    완전탐색과 dfs방식 모두 시간초과로 인해 풀 수 없었습니다.
    
    그래서 DP방식으로 문제풀이를 진행하였고 생각한 알고리즘은 다음과 같습니다.
    
    N개의 물건을 골라 최대 K의 무게까지 담았을 떄 최대 가치를 찾아내는 문제이므로
    
    1개 ~ N개까지 물건을 고르며 최대 무게가 K 까지이므로 가능한 무게 1 ~ K 까지 를 탐색하여
    
    최대가치를 갖는 값을 구하는 DP 알고리즘을 사용하여 문제를 해결하였습니다. 
    
 코 드 
 
 
     #include <iostream>
    #include <string>
    #include <queue>
    #include <algorithm>
    using namespace std;

    int N, K;
    int dp[101][100001]; // 최대 100개의 물건이 주어질 때 무게의 최대합은 10만 이므로
    
    // 100 * 100000 의 크기를 갖는 배열을 선언하여 DP풀이 진행
    
    int W[101]; // 무게 정보를 저장하는 배열
    
    int V[101]; // 가치 정보를 저장하는 배열

    void solve(){

      for (int a = 1; a <= N; ++a) { // 1 ~ N 개의 물건을 선택할 떄 
        for (int b = 1; b <= K; ++b) { // 1 부터 K 까지 여유 무게를 가질 떄 최대 가치를 찾는 탐색
          if (b >= W[a]) { // 현재 여유공간이 a번쨰 물건의 무게보다 클경우
          
            dp[a][b] = max(dp[a - 1][b], dp[a - 1][b - W[a]] + V[a]);
            // 현재 물건을 골라 W[a] 만큼 여유공간이 줄어든 상태의
            // 가방과 현재 물건을 고르지 않은 가방의 무게 중 더 큰 가치를 갖는 상태를
            //  dp 에 저장
          }
          else
          
            dp[a][b] = dp[a - 1][b];
            
            // 현재 가방의 여유공간이 a번째 물건을 넣을만큼 여유롭지 않다면
            // 현재 물건을 넣지않고 b 만큼 여유공간을 가진 이전 단계의 가치를 현재 dp배열에 저장
        }
      }
      cout << dp[N][K]; // N개의 물건을 모두 탐색하고 K의 무게를 모두 탐색했을 떄 최대 가치를 갖는
      // dp 값 dp[N][K]

    }
    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
      //freopen("Input.txt", "r", stdin);

      cin >> N >> K;

      for (int a = 1; a <= N; ++a) {
        cin >> W[a] >> V[a];
      }

      solve();
      return 0;
    }
