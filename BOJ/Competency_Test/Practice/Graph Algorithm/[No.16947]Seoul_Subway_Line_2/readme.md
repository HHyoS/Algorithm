문제 사이트 : https://www.acmicpc.net/problem/16947

문제 설명 :

    서울 지하철 2호선은 다음과 같이 생겼다.

![upload acmicpc](https://user-images.githubusercontent.com/57944215/149618007-8124c522-df4d-41a5-9856-3f8386245fd8.png)


    지하철 2호선에는 51개의 역이 있고, 역과 역 사이를 연결하는 구간이 51개 있다.
    
    즉, 정점이 51개이고, 양방향 간선이 51개인 그래프로 나타낼 수 있다. 
    
    2호선은 순환선 1개와 2개의 지선으로 이루어져 있다. 
    
    한 역에서 출발해서 계속 가면 다시 출발한 역으로 돌아올 수 있는 노선을 순환선이라고 한다. 
    
    지선은 순환선에 속하는 한 역에서 시작하는 트리 형태의 노선이다.

    두 역(정점) 사이의 거리는 지나야 하는 구간(간선)의 개수이다. 
    
    역 A와 순환선 사이의 거리는 A와 순환선에 속하는 역 사이의 거리 중 최솟값이다.

    지하철 2호선과 같은 형태의 노선도가 주어졌을 때, 각 역과 순환선 사이의 거리를 구해보자.

입력

    첫째 줄에 역의 개수 N(3 ≤ N ≤ 3,000)이 주어진다. 
    
    둘째 줄부터 N개의 줄에는 역과 역을 연결하는 구간의 정보가 주어진다. 
    
    같은 구간이 여러 번 주어지는 경우는 없고, 역은 1번부터 N번까지 번호가 매겨져 있다. 
    
    임의의 두 역 사이에 경로가 항상 존재하는 노선만 입력으로 주어진다.

출력

    총 N개의 정수를 출력한다.
    
    1번 역과 순환선 사이의 거리, 2번 역과 순환선 사이의 거리,
    
    ..., N번 역과 순환선 사이의 거리를 공백으로 구분해 출력한다.

예제 입력 1 

    4
    1 3
    4 3
    4 2
    1 2
    
예제 출력 1 

    0 0 0 0

예제 입력 2 

    6
    1 2
    3 4
    6 4
    2 3
    1 3
    3 5

예제 출력 2 

    0 0 0 1 1 2

예제 입력 3 

    51
    1 2
    2 3
    3 4
    4 5
    5 6
    6 7
    7 8
    8 9
    9 10
    10 11
    11 12
    12 13
    13 14
    14 15
    15 16
    16 17
    17 18
    18 19
    19 20
    20 21
    21 22
    22 23
    23 24
    24 25
    25 26
    26 27
    27 28
    28 29
    29 30
    30 31
    31 32
    32 33
    33 34
    34 35
    35 36
    36 37
    37 38
    38 39
    39 40
    40 41
    41 42
    42 43
    43 1
    11 44
    44 45
    45 46
    46 47
    34 48
    48 49
    49 50
    50 51

예제 출력 3 

    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 1 2 3 4

서울 지하철 2호선 노선이다.

1번부터 43번까지는 역 번호와 일치하며, 성수역은 11번, 신도림역은 34번이다.

예제 입력 4 

    38
    1 2
    2 3
    3 4
    4 5
    5 6
    6 1
    1 7
    7 8
    8 9
    9 10
    10 11
    11 12
    12 13
    13 14
    14 15
    15 16
    16 17
    17 18
    18 19
    19 20
    20 21
    21 22
    22 23
    23 24
    24 25
    25 26
    26 27
    27 28
    28 29
    29 30
    30 31
    31 32
    32 33
    33 34
    34 35
    35 36
    36 37
    37 38

예제 출력 4 

    0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
    
서울 지하철 6호선이다. 실제로는 일부 구간이 양방향이 아니다.

예제 입력 5 

    12
    1 3
    3 4
    4 5
    5 6
    6 7
    7 8
    8 4
    2 3
    7 9
    9 12
    7 10
    10 11
    
예제 출력 5 

    2 2 1 0 0 0 0 0 1 1 2 2
    
[ 풀이 알고리즘 ]

    주어진 정보를 이용하여 그래프를 구성하고, 그래프에 존재하는 사이클을 찾은 뒤, 
    
    모든 노드들에 대하여 사이클과의 최단거리를 찾는 문제였습니다.
    
    이 문제에서 가장 중요한 설명은 " 역의 개수와 간선의 개수가 같다 " 입니다.
    
    역의 개수보다 간선의 개수가 많다면, 사이클이 여러개 생길 수 있지만
    
    역의 개수와 간선의 개수가 같다면 생길 수 있는 사이클은 오직 한 사이클 존재할 수 있습니다.
    
    위 문제를 풀기위한 순서는 다음과 같습니다.
    
    1. 사이클 찾기.
    
    2. 모든 노드들에 대하여 사이클과 최단거리 찾기
    
    입니다.
    
    1. 사이클 찾기 는 모든 노드들에 대하여 DFS탐색방식을 통해 그래프의 사이클을 찾도록 하였고
    
    2. 최단거리 찾기는, 사이클에 포함된 노드는 0, 아닌 노드는 BFS탐색으로 최단거리를 찾도록하여
    
    문제를 해결하였습니다.
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    #include <utility>
    #include <vector>

    using namespace std;
    int N;
    vector<int> nosun[3000]; // 그래프의 구성요소를 저장하는 배열
    bool check[3000]; // DFS에 사용되는 사이클을 저장하는 배열
    bool ckck[3000]; // BFS에 사용되는 방문확인 배열
    bool ck = 0; // 사이클을 찾았는지 확인하는 변수
    
    void dfs(int idx, int target, int length) { // 사이클 찾기
        if (idx == target) { // 현재 탐색하는 곳이 목표 노드와 같다면
            if (length <= 2) // length가 2 이하면 사이클이 아닌 연결된 노드간의 왕복이므로 탈출
                return;
            ck = 1; // 사이클이면 다른 dfs탐색이 존재하지 않도록 ck = 1 
            return; // dfs종료
        }
        else {
            if (ck) // 사이클을 찾았다면 불필요한 dfs탈출
                return;
                
            for (int a = 0; a < nosun[idx].size(); ++a) { // 현재 방문한 노드에서 이동 가능한 노드 찾기
                if (!check[nosun[idx][a]]) { // 현재 노드에 연결된 노드를 아직 방문한적 없다면
                    check[nosun[idx][a]] = 1; // 방문체크하고 
                    dfs(nosun[idx][a], target, length + 1); // 탐색실시
                    if (ck) // dfs탐색 후 사이클을 찾았다면
                        break; // for문을 종료하여 check배열값 유지
                    check[nosun[idx][a]] = 0;
                }
            }
        }
    }

    void bfs(int num) { // 최단거리 찾기
        memset(ckck, 0, sizeof(ckck)); // ckck를 초기화해주고
        queue<int> que; 
        que.push(num); // 현재 위치부터 bfs탐색으로 사이클과 최단거리의 값 찾기
        ckck[num] = 1; // 현재 위치 방문표시하고
        int count = 1; // 최소 한칸 이동이므로 count = 1 부터 시작
        while (!que.empty()) {
            int size = que.size();
            for (int a = 0; a < size; ++a) { // que 사이즈만큼 for문을 반복하고
                int nd = que.front();
                que.pop();
                for (int b = 0; b < nosun[nd].size(); ++b) { // 현재 노드와 연결된 노드들 찾기
                    if (!ckck[nosun[nd][b]]) { // 연결된 노드가 방문하지 않은 노드라면
                    
                        if (check[nosun[nd][b]]) { // 다음 방문하려던 곳이 사이클이라면
                            cout << count << " "; // 현재까지 이동횟수 출력 후
                            return; // BFS함수 탈출
                        }
                        
                        ckck[nosun[nd][b]] = 1; // 방문표시
                        que.push(nosun[nd][b]); // que에 추가
                    }
                }
            }
            ++count;
        }
    }
    int main() {
        ios::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        //freopen("Input.txt","r", stdin);

        cin >> N;
        int n1, n2;
        for (int a = 0; a < N; ++a) { // 그래프 정보 입력
            cin >> n1 >> n2;
            nosun[n1 - 1].push_back(n2 - 1);
            nosun[n2 - 1].push_back(n1 - 1);
        }
        for (int a = 0; a < N; ++a) { // 사이클을 찾기위한 DFS탐색 실시
            for (int b = 0; b < nosun[a].size(); ++b) {
                check[nosun[a][b]] = 1;
                dfs(nosun[a][b], a, 1);
                if (ck) { // 사이클을 찾았다면 
                    a = N; // 첫번쨰 for문 탈출을 위해 a = N을 넣어주고
                    break; // 두번쨰 for문 break
                }
                check[nosun[a][b]] = 0;
            }
        }
        for (int a = 0; a < N; ++a) {
            if (check[a]) // a번 노드가 사이클에 포함되어있다면 
                cout << "0 "; // 0 출력
            else { // 아니라면
                bfs(a); // 탐색 실시
            }
        }
        return 0;

    }

