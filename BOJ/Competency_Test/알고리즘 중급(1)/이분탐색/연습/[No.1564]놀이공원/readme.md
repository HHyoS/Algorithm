문제 사이트 : https://www.acmicpc.net/problem/1561

문제 설명 :

    N명의 아이들이 한 줄로 줄을 서서 놀이공원에서 1인승 놀이기구를 기다리고 있다.
    
    이 놀이공원에는 총 M종류의 1인승 놀이기구가 있으며, 1번부터 M번까지 번호가 매겨져 있다.

    모든 놀이기구는 각각 운행 시간이 정해져 있어서, 운행 시간이 지나면 탑승하고 있던 아이는 내리게 된다. 
    
    놀이 기구가 비어 있으면 현재 줄에서 가장 앞에 서 있는 아이가 빈 놀이기구에 탑승한다.
    
    만일 여러 개의 놀이기구가 동시에 비어 있으면, 더 작은 번호가 적혀 있는 놀이기구를 먼저 탑승한다고 한다.

    놀이기구가 모두 비어 있는 상태에서 첫 번째 아이가 놀이기구에 탑승한다고 할 때, 
    
    줄의 마지막 아이가 타게 되는 놀이기구의 번호를 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 N(1 ≤ N ≤ 2,000,000,000)과 M(1 ≤ M ≤ 10,000)이 빈칸을 사이에 두고 주어진다.
    
    둘째 줄에는 각 놀이기구의 운행 시간을 나타내는 M개의 자연수가 순서대로 주어진다.
    
    운행 시간은 1 이상 30 이하의 자연수이며, 단위는 분이다.

출력

    첫째 줄에 마지막 아이가 타게 되는 놀이기구의 번호를 출력한다.

예제 입력 1 

    3 5
    7 8 9 7 8

예제 출력 1 

    3

예제 입력 2 

    7 2
    3 2

예제 출력 2 

    2

예제 입력 3 

    22 5
    1 2 3 4 5

예제 출력 3 

    4 
    
풀이 알고리즘

    놀이기구의 갯수와 소요시간, 그리고 놀이기구 탑승객이 주어졌을 때, 탑승객 중 마지막 사람이 타게되는
    
    놀이기구의 번호를 출력하는 문제였습니다.
    
    이분탐색을 통해 탑승객 전원이 놀이기구를 타는데 필요한 시간을 구할 수 있었지만, 마지막으로 타게되는
    
    놀이기구를 찾는게 어려운 문제였습니다.
    
    이 문제에서 마지막으로 탄 놀이기구를 찾는데 필요한 정보 놀이기구를 타는데 필요한 시간이고, 거기에 약간의
    
    응용이 필요한 문제입니다.

    1. 이분탐색을 통해 구한 모든 사람이 놀이기구를 타는데 필요한 시간이 T라고 한다면, T시간에는 모든 사람들이
    
    놀이기구를 타고있습니다.
    
    2. 그렇다면 T-1 시간에는 모든 사람이 놀이기구를 탄 상태가 아닌것이고, T시간이 되었을 때, 모든사람이
    
    놀이기구를 타고있는 상태입니다.
    
    3. N명의 사람들 중 T-1 시간에 놀이기구를 타고있는 사람을 제외하면 그 사람들이 T시간에 놀이기구를 탄
    
    사람들이 되게됩니다.
    
    4. 그래서 T-1시간에 놀이기구를 탄 사람을 제외한 값을 Q라고한다면, T시간이 되었을 떄 사람이 탈 수 있는
    
    놀이기구를 찾고(T%소요시간 = 0 이되는 놀이기구) 해당 놀이기구를 찾게되면 남은 인원에서 한명씩 제외해줍니다.
    
    5. 4를 반복하여 남은 사람이 0명이 되는 놀이기구를 찾게되면 해당 놀이기구가 마지막에 사람이 탄 놀이기구가
    
    됩니다.
    
구  현

    #include<iostream>
    #include<string>
    #include<algorithm>
    #include<queue>


    using namespace std;
    long long N, M;
    long long arr[10001];
    long long maxi;

    void bs() {
      long long s = 1;
      long long e = maxi * N;
      long long ans = 0;
      long long count = 0;
      while (s <= e) {
        long long mid = (s + e) / 2;

        long long cnt = 0;
        for (int a = 0; a < M; ++a) {
          cnt += (mid / arr[a])+1;
          if (cnt >= N)
            break;
        }

        if (cnt >= N) {
          e = mid - 1;
          ans = mid;
        }
        else {
          s = mid + 1;
        }
      }

      int idx = 0;
      ans = ans - 1;
      long long  t = 0;
      for (int a = 0; a < M; ++a) {
        t+= ans / arr[a]+1;
      }

      ans += 1;
      for (int a = 0; a < M; ++a) {
        if (ans % arr[a] == 0)
          ++t;

        if (t == N) {
          idx = a + 1;
          break;
        }

      }

      cout << idx;
    }
    void input() {
      cin >> N >> M;
      for (int a = 0; a < M; ++a) {
        cin >> arr[a];
        if (maxi < arr[a])
          maxi = arr[a];
      }


    }
    int main()
    {
      ios::sync_with_stdio(false);

      cin.tie(NULL);
      cout.tie(NULL);

      input();

      if (M >= N) {
        cout << N;
      }
      else
        bs();
      return 0;

    }
    
    
풀이 인증

![image](https://user-images.githubusercontent.com/57944215/187057122-933f16cc-854b-4a9e-a177-2f27ef3d2dd5.png)
