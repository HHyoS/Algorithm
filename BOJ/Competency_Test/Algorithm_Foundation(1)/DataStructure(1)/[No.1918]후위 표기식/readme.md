문제 사이트 : https://www.acmicpc.net/problem/1918

문제 설명 :

    수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 
    
    연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 
    
    연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation),
    
    연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 
    
    예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 
    
    후위 표기법으로는 ab+가 된다.

    이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 
    
    후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 
    
    이 방법의 장점은 다음과 같다. 
    
    우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 
    
    차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 
    
    순서를 적절히 조절하여 순서를 정해줄 수 있다. 
    
    또한 같은 방법으로 괄호 등도 필요 없게 된다. 
    
    예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.

    중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다.
    
    우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 
    
    그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

    예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 
    
    그 다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 (a+bc*)가 된다.
    
    마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.

    다른 예를 들어 그림으로 표현하면 A+B*C-D/E를 완전하게
    
    괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.



    결과: ABC*+DE/-

    이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오

입력

    첫째 줄에 중위 표기식이 주어진다. 
    
    단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다.
    
    그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다.
    
    표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다. 

출력

    첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

예제 입력 1 

    A*(B+C)

예제 출력 1 

    ABC+*

예제 입력 2 

    A+B

예제 출력 2 

    AB+

예제 입력 3 

    A+B*C

예제 출력 3 

    ABC*+

예제 입력 4 
  
    A+B*C-D/E

예제 출력 4 

    ABC*+DE/-


[ 풀 이 ]

    일반적인 중위 표기법을 후위 표기법으로 변환하여 출력하는 문제였습니다.
    
    후위 표기법은 연산자가 피연산자 뒤에 표기되는 표기법인데 이를 프로그램으로 구현할 떄
    
    stack을 사용하여 전위 -> 후위 표기법으로 변환하는것이 일반적입니다.
    
    stack을 사용하여 변환 할 때 생각해야하는 점은 다음과 같습니다.
    
    1. '+' , '-' 연산자가 나왔을 떄 stack에 '(' 가 존재하는 것이 아니라면 stack의 모든 연산자를
    
     pop 연산하여 stack을 비운 후 stack 에 해당 연산자를 push 연산한다.
     
    2. '*' , '/' 연산자가 나왔을 때 stack에 상단에 존재하는 '*' 와 '/' 연산자를 모두 pop 연산하여
    
    비워준 뒤, stack 에 연산자를 push 한다.
    
    3. '(' 연산자가 나왔다면 그냥 stack 에 push
    
    4. ')' 연산자가 나왔다면 '(' 연산자가 나올떄까지 stack을 모두 pop연산하여 비워준다.
    
    5. 표기식의 끝까지 모두 탐색이 완료되었다면, stack에 존재하는 모든 연산자를 pop연산하여
    
    비워준뒤 출력하여 문제 해결
    
[ 구 현 ]

    #include <iostream>
    #include <string>
    #include <stack>
    using namespace std;


    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
      string S;
      //freopen("Input.txt", "r", stdin);
      cin >> S;
      stack<char> stk;
      string answer; // 정답을 저장하는 변수
      for (int a = 0; S[a]; ++a) {
        if (S[a] >= 'A' && S[a] <= 'Z') { // 일반 피연산자라면 바로 answer에 추가해준다.
          answer = answer + S[a];
        }
        else {
          if (S[a] == '+' || S[a] == '-') { // '+' 나 '-'라면 
            while (!stk.empty() && stk.top() != '(') { // stack의 상단에 '('값을 제외한 모든
              answer += stk.top(); // 피연산자를 answer에 추가해주고 pop연산하여 비워준다.
              stk.pop();
            }
            stk.push(S[a]); // 그 이후 stack에 현재 연산자 push
          }
          else if (S[a] == '*' || S[a] == '/') { // '*' 나 '/' 연산자가 나왔다면
            while (!stk.empty() && (stk.top() == '*' || stk.top() == '/')) {
              answer += stk.top(); // stack의 상단에 존재하는 '*' 와 '/'를 모두 pop연산하여
              stk.pop(); // answer에 더해준 후
            }
            stk.push(S[a]); // stack에 현재 연산자 push
          }
          else {
            if (S[a] == '(') {
              stk.push(S[a]); // '(' 라면 그냥 stack 에 push 해주고
            }
            else {
              while (stk.top() != '(') { // ')' 라면
                answer += stk.top(); // stack에 '('를 만날떄까지 answer에 더해주고 모두 pop해준 뒤
                stk.pop();
              }
              stk.pop(); // stk.top()에 존재하는 '(' 제거해주기
            }
          }
        }
      }
      while (!stk.empty()) { // 전위 표기식을 모두 탐색완료했다면
        answer += stk.top(); // stack에 남아있는 연산자 모두 사용
        stk.pop();
      }
      cout << answer; // answer 
      return 0;
    }

    
    
