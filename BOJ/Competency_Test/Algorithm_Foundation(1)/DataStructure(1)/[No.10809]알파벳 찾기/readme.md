문제 사이트 : https://www.acmicpc.net/problem/10809

문제 설명 :

    알파벳 소문자로만 이루어진 단어 S가 주어진다. 
    
    각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를,
    
    포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.

입력

    첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며,
    
    알파벳 소문자로만 이루어져 있다.

출력

    각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치,
    
    ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.

    만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다.
    
    단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.

예제 입력 1 

    baekjoon
    
예제 출력 1 

    1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1

[ 풀 이 ]

    문자열이 주어졌을 때, 알파뱃이 처음 등장하는 위치를 알파뱃 순서대로 출력하는 문제였습니다.
    
    문제 풀이를 위해  알파뱃의 갯수인 26개만큼의 배열 alpha[26] 선언한 뒤, 
    
    default 값인 -1로 세팅해 주었습니다
    
    그 이후 S[0] ~ S[n] 까지 방문하며 아스키코드를 활용하여( a = 97, b = 98 .... )
    
    해당 알파뱃의 위치를 방문하지 않았다면( alpha[n-97] == -1 ) 현재 alpha[n -97]에 
    
    현재 위치인 n값을 넣고 아니라면 넘어가는 방식으로 alpha배열의 값을 저장하고
    
    모든 알파뱃에 방문이 끝나면 배열을 순서대로 출력하여 문제를 해결하였습니다.
    
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    using namespace std;

    char S[101];
    int alpha[26];
    int main() {

      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);

      //freopen("Input.txt", "r", stdin);
      for (int a = 0; a < 26; ++a) {
        alpha[a] = -1; // default 값 세팅
      }

      cin >> S;
      for (int a = 0; S[a]; ++a) {
        if (alpha[S[a] - 97] == -1) // 현재 방문한 S[a]에 위치한 알파뱃을 아직 방문한적이 없다면
          alpha[S[a] - 97] = a; // alpha[S[a] - 97] 에 현재 index를 저장
      }

      for (int a = 0; a < 26; ++a) {
        cout << alpha[a] << " "; // 순서대로 출력
      }

      return 0;
    }
    
    
    
    
   
    
    
