문제 사이트 : https://www.acmicpc.net/problem/16922

문제 설명 : 

    로마 숫자에서는 수를 나타내기 위해서 I, V, X, L을 사용한다. 
    
    각 문자는 1, 5, 10, 50을 의미하고, 이 문제에서 다른 문자는 사용하지 않는다.

    하나 또는 그 이상의 문자를 이용해서 수를 나타낼 수 있다. 
    
    문자열이 나타내는 값은, 각 문자가 의미하는 수를 모두 합한 값이다.
    
    예를 들어, XXXV는 35, IXI는 12를 의미한다.

    실제 로마 숫자에서는 문자의 순서가 중요하지만, 이 문제에서는 순서는 신경쓰지 않는다.
    
    예를 들어, 실제 로마 숫자에서 IX는 9를 의미하지만, 이 문제에서는 11을 의미한다.

    로마 숫자를 N개 사용해서 만들 수 있는 서로 다른 수의 개수를 구해보자.

입력

    첫째 줄에 사용할 수 있는 문자의 개수 N (1 ≤ N ≤ 20)이 주어진다.

출력

    첫째 줄에 로마 숫자 N개를 사용해서 만들 수 있는 서로 다른 수의 개수를 출력한다.

예제 입력 1 

    1

예제 출력 1 

    4

I, V, X, L을 만들 수 있다.

예제 입력 2 

    2

예제 출력 2 

    10
    
2, 6, 10, 11, 15, 20, 51, 55, 60, 100을 만들 수 있다.

예제 입력 3 

    10
    
예제 출력 3

    244
    
[ 풀이 알고리즘 ]

    여러 선택지에 대해서 중복선택이 가능한 중복조합 문제였습니다. 
    
    하지만 단순한 중복조합이 아니라 중복조합으로 선택한 로마 숫자들의 합 유니크한 값이여야 하는 조건이 달려있습니다.
    
    즉. 이전에 특정 조합으로 만들어진 로마숫자의 합이 또 만들어질 경우 만든 경우의 수로 취급하지 않아야 했습니다.
    
    그래서 문제의 풀이 알고리즘은 크게 두가지로 다음과 같습니다.
    
    1. 중복조합으로 주어진 N에 대하여 조합을 만든다.
    2. 중복조합의 선택으로 만들어진 값이 이전에 존재했던 값이 아닐경우 경우의수 1 추가.
    2 - 1 존재할 경우 무시
    
[ 구 현 ] 

#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <utility>

using namespace std;
int N;
int roma[4] = { 1,5,10,50 };
bool check[1001];
int answer = 0;
void dfs(int count,int sum,int idx){ // count = 남은 선택지, sum = 지금까지 로마숫자의 합, idx = 중복조합을 위해 사용되는 idx
	if(count ==0){
		if (!check[sum]){ // 이전에 만들어지지 않은 숫자일경우
			check[sum] = 1; // 해당 숫자 제작 표시
			++answer; // 경우의 수 1 추가
		}
		return; // dfs종료
	}
	else {
		for (int a = idx; a < 4; ++a) { // 탐색은 idx부터하도록하여 불필요한 반복을 줄임
			dfs(count - 1, sum + roma[a],a); 
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);


//	freopen("Input.txt", "r", stdin);

	//dfs(X, Y,0);
	cin >> N;
	for (int a = 0; a < 4; ++a) { // 숫자 선택의 시작
		dfs(N - 1, roma[a],a);
	}

	cout << answer;
	return 0;
}
