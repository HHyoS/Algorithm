문제 사이트 : https://www.acmicpc.net/problem/16968

문제 설명 :

    상도시의 차량 번호판 형식이 주어졌을 때,
    
    가능한 차량 번호판의 개수를 구해보자.
    
    번호판에 사용할 수 있는 숫자는 0, 1, 2, ..., 8, 9이다.
    
    사용할 수 있는 문자는 a, b, c, d, ..., y, z이다.
    
    차량 번호판의 형식은 최대 4글자이고, c와 d로 이루어진 문자열로 나타낼 수 있다.
    
    c는 문자가 위치하는 자리, d는 숫자가 위치하는 자리이다.
    
    같은 문자 또는 숫자가 연속해서 2번 나타나면 안 된다.
    
    예를 들어, 형식이 "cd"이면, a1, d4, h5, k4 등이 가능하다. 
    
    형식이 "dd"인 경우에 01, 10, 34, 69는 가능하지만,
    
    00, 11, 55, 66은 같은 숫자가 2번 연속해서 불가능하다.

입력

		첫째 줄에 차량 번호판의 형식이 주어진다.
    
    형식은 길이가 4보다 작거나 같으며, c와 d로만 이루어져 있다.

출력

    첫째 줄에 가능한 차량 번호판의 개수를 출력한다.

예제 입력 1 

    dd

예제 출력 1 

    90

00부터 99까지 총 100가지 중에서 00, 11, 22, 33, 44, 55, 66, 77, 88, 99가 불가능하다.

예제 입력 2 

    cc

예제 출력 2 

    650
    
262 = 676가지 중에서 같은 문자가 중복되는 26가지가 불가능하다.

예제 입력 3 

    dcdd

예제 출력 3 

    23400 
    
풀이 알고리즘

    주어진 규칙에 맞추어 나올 수 있는 번호판 경우의 수를 출력하는 문제였습니다.
    
    처음에 문제를 풀며 든 생각은 '이거 Bruete Force가 아니더라도 규칙찾으면 풀 수 있겠는데?' 였습니다.
    
    규칙을 찾아 푼 문제가 Car_License_Plate(수학).cpp 의 이름으로 업로드한 파일이였습니다.
    
     Car_License_Plate(수학).cpp 를 구현하며 찾은 이 문제의 규칙은 굉장히 단순합니다.
     
 [Case 1] Car_License_Plate(수학).cpp
    
    길이가 4인 번호판의 형식이 만약 ccdd로 주어진다면, c = 26, d = 10의 경우의 수를 가지며, 연속해서 사용될 경우 c = 25, d = 9 라는 경우의 수를 가지게됩니다.
    
    단순 곱셈으로 26 * 25 * 10 * 9 = 58,500 이 나오게 되고, 문제에서는 최대 4자리까지만 주어지지만, 6자리가 주어진다고 가정하고
    
    dddddd 라는 형식이 주어지면 10 * 9 * 9 * 9 * 9 * 9 = 590,490 가 문제의 답이 됩니다.
     
 [Case 2] Car_License_Plate.cpp
    
    Car_License_Plate.cpp 파일은 전형적인 BrueForce 방식으로 푼 문제입니다.
    
    하지만 일반적인 BruteForce 문제와 다르게, 이전 인덱스에서 사용되었던 값만을 연속해서 쓰지않으므로, 매개변수로 해당 값을 전달하여 
    
    다음단계에서 이전단계에 사용된 값만을 사용하지 않도록하여 구현하였습니다.
    

[ 구 현 ] - Car_License_Plate.cpp

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <set>
    using namespace std;
    int N;
    string iput;
    long answer;

    void dfs(int idx,int before) { // before은 전 단계에 사용된 알파뱃, 혹은 숫자를 의미.
    // idx는 입력받은 형식을 저장하는 변수 iput의 index를 의미하는 변수로 iput의 앞부터 뒤로 탐색하며
    // idx의 값이 iput의 길이와 같아지면 dfs탐색을 종료하기위해 사용되었습니다.
      if (idx == iput.size()) {
        ++answer; // idx가 iput의 끝까지 탐색했음을 의미하면 경우의 수 갯수를 의미하는 answer를 하나 증가시키고
        return; // dfs 탈출
      }
      else { // idx가 아직 iput의 끝까지 도달하지 못했다면
        if (iput.at(idx) == 'd') { / iput의 idx에 해당하는 위치의 알파뱃을 확인한 후 'd' 정수라면
          ++idx; // 다응 탐색을 위해 idx를 증가시키고
          for (int a = 0; a < 10; ++a) { // 0 부터 9까지 값을 넣기 위한 for문
            if (a != before) // 이전 단계에 a위치에 해당하는 알파뱃, 혹은 숫자가 사용되지 않았다면
              dfs(idx, a); // 탐색 실시, 이전에 사용된 값을 의미하는 매개변수 before의 자리에는 a 전달
          }
        }
        else { // 현재 위치가 알파뱃을 넣어야 하는 위치라면
          ++idx; / 다음 탐색을 위해 idx를 증가시키고
          for (int a = 10; a < 36; ++a) { // 알파뱃은 26자리므로 a ~ z 까지 for문 
            if (a != before) // 현재 위치가 before, 즉 전 단계에 사용되지 않았다면
              dfs(idx, a); // 탐색 실시
          }
        }
      }
    }
    int main() {
      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
      freopen("Input.txt", "r", stdin);
      cin >> iput;

      if (iput.at(0) == 'd') {
        for (int a = 0; a < 10; ++a) { // 이 코드 전체에서 a가 사용되는 범위는 0 ~ 35까지인데, 그 중 0 ~ 9는 숫자를 의미하고
          dfs(1, a);
        }
      }
      else { 
        for (int a = 10; a < 36; ++a) { // 10 ~ 35까지는 a ~ z 를 의미하도록 하여, iput에서 현재 위치에 요구하는 값이 'd'일경우 0 ~ 9
        // 'c' 일경우 10 ~ 36을 사용하도록 하여 이전 단계에 사용했는지에 대해 int값으로 한번에 처리할 수 있도록 구현하였습니다.
          dfs(1, a);
        }
      }
      cout << answer;
      return 0;
    }


  
