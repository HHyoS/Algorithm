문제 사이트 : https://www.acmicpc.net/problem/16917

문제 설명 : 

    현진 치킨에서 판매하는 치킨은 양념 치킨, 후라이드 치킨, 반반 치킨으로 총 세 종류이다. 
    
    반반 치킨은 절반은 양념 치킨, 절반은 후라이드 치킨으로 이루어져있다.
    
    양념 치킨 한 마리의 가격은 A원, 후라이드 치킨 한 마리의 가격은 B원, 
    
    반반 치킨 한 마리의 가격은 C원이다.

    상도는 오늘 파티를 위해 양념 치킨 최소 X마리, 
    
    후라이드 치킨 최소 Y마리를 구매하려고 한다. 
    
    반반 치킨을 두 마리 구입해 양념 치킨 하나와 후라이드 치킨 하나를 만드는 방법도 가능하다.
    
    상도가 치킨을 구매하는 금액의 최솟값을 구해보자.


입력

    첫째 줄에 다섯 정수 A, B, C, X, Y가 주어진다.

출력

    양념 치킨 최소 X마리, 후라이드 치킨 최소 Y마리를 구매하는 비용의 최솟값을 출력한다.

제한

    1 ≤ A, B, C ≤ 5,000
    1 ≤ X, Y ≤ 100,000

예제 입력 1 

    1500 2000 1600 3 2
    
예제 출력 1 

    7900
    반반 치킨 4마리를 구매해서,
    
    양념 치킨 2마리와 후라이드 치킨 2마리를 만들고,
    
    양념 치킨 1마리를 구매하는 것이 최소이다.

예제 입력 2 

    1500 2000 1900 3 2

예제 출력 2 

    8500

예제 입력 3 

    1500 2000 500 90000 100000

예제 출력 3 

    100000000
 
[ 풀이 알고리즘 ]

    후라이드, 양념, 반반 치킨의 가격이 각각 주어지고,
    
    사야하는 후라이드 치킨의 갯수 X, 양념치킨의 갯수 Y가 주어질 떄
    
    가장 효율적으로 X와 Y를 만족하는 치킨 조합을 만드는 문제였습니다.
    
    BrueForce로 분류된 문제이지만 단순 완전탐색으로 푸는것은 비효율적으로 생각되었고, 
    
    문제의 규칙을 찾아보게 되었습니다.
    
    [ 생각 ]
    
    이 문제의 핵심은 효율적으로 구매를 하여 비용을 최소화 하는 것입니다.
   
    그렇기때문에 후라이드(1마리) + 양념(1마리) vs 반반(2마리) 중 효율적인것을 골라 처리하면 되는데
    
    효율을 세가지를 생각해볼 수 있습니다.
    
    후라이드 한마리 = Q, 양념 한마리 = W , 반반 두마리 = E 라고 할때
    
    1. 반반치킨이 압도적으로 효율적이여서 Q > E, W > E 라면
   
    치킨의 갯수 X,Y를 모두 0으로 만들때 까지 반반치킨만을 구매하면 됩니다.
    
    2. Q + W > E 이지만 ( (Q < E) || (W < E) ) 로, 반반 두마리가 후라이드 한마리[ Q ] 혹은 
    
    양념 한마리[ W ] 를 사는 값 중 하나가 반반 두마리 보다 효율적일경우
    
    (1) 양념과 후라이드 중 필요로 하는 갯수가 더 적은 값을 먼저 0으로 만들고, 
    
    (2) 남은 치킨 한마리의 값과 반반치킨 두마리의 효율을 계산하여 무엇을 살지 선택하기
    
    3. 반반 치킨의 효율이 좋지 않아서 후라이드, 양념을 그냥 사는것이 더 저렴할경우
    
    최종 값은 = Q * X + W * Y
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    #include <utility>

    using namespace std;
    int X, Y;            
    long price[3]; // price[0] = 후라이드 값, price[1] = 양념 값, price[2] = 반반값

    int main() {
      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);

      freopen("Input.txt", "r", stdin);
      cin >> price[0] >> price[1] >> price[2];
      cin >> X >> Y;

      //dfs(X, Y,0);
      long sum = 0;

      if (price[0] + price[1] > price[2] * 2) { // 반반 두마리 값 < 후라이드 + 양념 값 일경우
        if (X > Y) { // 작은 값을 0으로 만들기 위해 큰값 찾기

          X -= Y; // Y마리의 양념치킨을 먼저 제거하기 위해 반반치킨을 시키면
          // Y마리만큼 후라이드 치킨도 주문하는것이므로 X = X - Y
          sum = (price[2] + price[2]) * Y; // 반반치킨 두마리당 양념 한마리이므로
          // 2 * Y 마리의 반반치킨 주문
          
          if(price[0] > price[2] * 2) // 남아있는 치킨이 후라이드고, 
          // 후라이드 한마리보다 반반 두마리가 더 저렴할 경우
            sum = sum +( price[2] + price[2])* X;
            // 반반치킨으로 남은 X 처리
          else // 후라이드 한마리가 더 저렴할 경우
            sum = sum + price[0] * X; // 후라이드로 남은 X 처리
        }
        else { // Y, 양념치킨이 후라이드 치킨보다 필요갯수가 많을경우

          Y -= X; // X마리만큼 Y를 빼고
          sum = (price[2] + price[2] )* X; // 2*X 마리만큼 반반치킨 주문

          if (price[1] > price[2] * 2) // 양념치킨 한마리보다 반반치킨 두마리가 더 저렴할경우
            sum = sum + (price[2] + price[2]) * Y; // 반반치킨으로 남은 Y 를 0으로 만들기

          else // 양념 한마리가 더 효율적일경우
            sum = sum + price[1] * Y; // 양념으로 남은 Y 처리
        }
      }
      else { // 후라이드 + 양념 < 반반 두마리 로 반반치킨의 효율이 안좋을 경우
        sum = X * price[0] + Y * price[1]; // 필요한 갯수만큼 후라이드. 양념 
      }
      cout << sum;

      return 0;
    }

