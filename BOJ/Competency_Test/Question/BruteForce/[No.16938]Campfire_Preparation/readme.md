문제 사이트 : https://www.acmicpc.net/problem/16938

문제 설명 :

    알고리즘 캠프를 열려면 많은 준비가 필요하다. 
    
    그 중 가장 중요한 것은 문제이다. 
    
    오늘은 백준이를 도와 알고리즘 캠프에 사용할 문제를 고르려고 한다.

    백준이는 문제를 N개 가지고 있고, 모든 문제의 난이도를 정수로 수치화했다. 
    
    i번째 문제의 난이도는 Ai이다.

    캠프에 사용할 문제는 두 문제 이상이어야 한다.
    
    문제가 너무 어려우면 학생들이 멘붕에 빠지고, 문제가 너무 쉬우면 학생들이 실망에 빠지게 된다. 
    
    따라서, 문제 난이도의 합은 L보다 크거나 같고, R보다 작거나 같아야 한다. 
    
    또, 다양한 문제를 경험해보기 위해 가장 어려운 문제와 가장 쉬운 문제의 난이도 차이는 X보다 크거나 같아야 한다.

    캠프에 사용할 문제를 고르는 방법의 수를 구해보자.

   입력
    
    첫째 줄에 N, L, R, X가 주어진다.

    둘째 줄에는 문제의 난이도 A1, A2, ..., AN이 주어진다.

   출력
   
    캠프에 사용할 문제를 고르는 방법의 수를 출력한다.

   제한
   
    1 ≤ N ≤ 15
    1 ≤ L ≤ R ≤ 109
    1 ≤ X ≤ 106
    1 ≤ Ai ≤ 106
    
   예제 입력 1 
   
    3 5 6 1
    1 2 3
    
   예제 출력 1 
   
    2
    
   2번, 3번 문제를 고르는 방법, 모든 문제를 고르는 방법이 가능하다.

   예제 입력 2 
   
    4 40 50 10
    10 20 30 25
    
   예제 출력 2 
   
    2
    
   난이도가 10, 30인 문제를 고르거나, 20, 30인 문제를 고르면 된다.

   예제 입력 3 
   
    5 25 35 10
    10 10 20 10 20
    
   예제 출력 3 
   
    6

풀이 알고리즘

    1. 주어진 N개의 숫자 중, nC2, , nC3,nC4 .... nCn 의 경우의 수 중
    
    최소값이 주어진 L보다 크고, 최대값이 R보다 작고, 선택된 문제의 수의 난이도 합이 X보다 작은
    
    경우의 수 갯수를 찾는 문제였습니다.
    
    2. 풀이 알고리즘은 다음과 같습니다.
      1) 문제 해결을 위해 문제를 ?개 뽑는 경우의 수를 진행 할 때, 배열이 정렬되어 있지않으면
        ?개를 뽑은 이후 최소, 최대값을 따로 찾아줘야하기 때문에 배열을 미리 정렬해두기.
      2) for문을 이용하여 2 ~ n 개를 뽑는 경우의 수를 구현해주고.
      3) for문을 하나 더 추가하여, 뽑기의 위치를 선택합니다.
      4) 뽑기의 위치가 선택되었다면 해당값을 작은수로 설정.
      5) dfs탐색을 통해 ?개만큼 뽑기가 진행되면 마지막에 뽑기가 진행 된 값을 최대값으로 설정.
      6) 5) 의 단계가 지난 이후 dfs가 한번 더 실행되면 
        최소값이 주어진 L보다 크고, 최대값이 R보다 작고, 
        선택된 문제의 수의 난이도 합이 X보다 작은지 if문으로 구현하여 확인한 후
        조건을 충족시킨다면 경우의 수의 갯수 1추가.
      7) n개중 n개를 뽑아 조건과 비교하는 것까지 끝낫다면 경우의 갯수 출력
 

[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    using namespace std;
    
    int N, L,R, X;
    
    int num[16];
    
    bool check[16];
    int answer = 0;
    void dfs(long long v,int deep,int frst, int lst,int idx) {
      if (deep == 0) {
        if ((v >= L) && (v <= R) && (lst - frst >= X)) {
        // 최소값이 주어진 L보다 크고, 최대값이 R보다 작고,
        // 선택된 문제의 수의 난이도 합이 X보다 작은 경우라면
      //		cout << frst << " " << lst << " " << v << "\n";
          ++answer; // 경우의 수 ++
        }
        return; dfs 종료
      }
      else {
        --deep; // 하나를 선택할 예정이기 떄문에 deep을 하나 뺴주고
        ++idx; // idx의 위치를 하나 오른쪽으로 옮김
        if (idx >= N) // 옮긴 idx의 위치가 범위 밖이라면
          return; // 탈출

        if (deep == 0) { // 뽑기를 했을 떄 다음 단계가 없을 예정이라면
          lst = num[idx]; // 가장 큰 값으로 현재 idx의 값을 저장
        }

        dfs(v + num[idx], deep, frst, lst, idx);
        // 현재 idx의 값을 뽑았으므로 합은 v + num[idx], 남은 뽑기갯수 deep, 
        // 작은 수 frst, 큰수 lst, 위치 idx

        ++deep;
        // 다음 dfs은 이번 idx를 선택하지 않는 경우의 수 이므로 deep ++
        dfs(v, deep, frst, lst, idx);
        

      }

    }
    int main() {
      ios::sync_with_stdio(0);
      cin.tie(0);
      cout.tie(0);
    //	freopen("Input.txt", "r", stdin);

      cin >> N >> L >> R >> X;
      for (int a = 0; a < N; ++a)
        cin >> num[a]; // 문제의 정보 입력받기

      sort(num, num + N); // 문제의 값이 작은 값 ~ 큰값 순으로 정렬

      for (int a = 2; a <= N; ++a) { // n개의 문제 중 2 ~ n개뽑기 실시
        for (int b = 0; b < N; ++b) {
          dfs(num[b], a-1,num[b],0,b);
          // 초기값은 num[b], 앞으로 남은 뽑기갯수 a-1개, 최소값은 num[b], 
          // 최대값은 아직 정해지지 않았고, 현재 index 위치는 b
        }
      }
      cout << answer; // 경우의 수 갯수 
      return 0;
    }


    
