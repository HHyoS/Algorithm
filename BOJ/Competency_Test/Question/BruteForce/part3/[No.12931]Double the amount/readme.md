문제 사이트 : https://www.acmicpc.net/problem/12931

문제 설명 :

    모든 값이 0으로 채워져 있는 길이가 N인 배열 A가 있다. 
    
    영선이는 다음과 같은 두 연산을 수행할 수 있다.

    배열에 있는 값 하나를 1 증가시킨다.
    
    배열에 있는 모든 값을 두 배 시킨다.
    
    배열 B가 주어졌을 때, 배열 A를 B로 만들기 위한 연산의 최소 횟수를 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 배열의 크기 N이 주어진다. (1 ≤ N ≤ 50)

    둘째 줄에는 배열 B에 들어있는 원소가 공백으로 구분해서 주어진다. 배열에 B에 들어있는 값은 0보다 크거나 같고, 1,000보다 작거나 같다.

출력

    첫째 줄에 배열 A를 B로 바꾸기 위한 최소 연산 횟수를 출력한다.

예제 입력 1 

    2
    2 1

예제 출력 1 

    3

예제 입력 2 

    3
    16 16 16

예제 출력 2 

    7

예제 입력 3 

    1
    100

예제 출력 3 

    9

예제 입력 4 

    5
    0 0 1 0 1

예제 출력 4 

    2   
    
[ 풀이 알고리즘 ]

    모든값이 0으로 채워진 A 배열을 
    
    조건 1. 배열에 있는 값 하나를 1 증가시킨다.
    조건 2. 배열에 있는 모든 값을 두 배 시킨다.
    
    두 가지 조건에 맞추어 B 배열로 만드는 최소연산을 찾는 방법을 찾는 문제였습니다.
    
    최소 연산으르 찾기 위해서는 조건 2 를 최대한 활용하는 방법을 찾아 사용해야 했습니다.
    
    그 방법을 찾기 위해서 사용한 방법은 다음과 같습니다.
    
    과정 1. B 배열 -> A배열로 만드는 방식
    
    과정 2. B 배열의 원소를 모두 2의 배수 혹은 0으로 만들기 (조건 2 연산)
    
    과정 3. ( 과정 2 ) 를 수행하며 2의 배수로 만들기 -> 조건 1 을 사용하여 1빼기 연산
    
    과정 4. 모든 배열의 원소가 0이되면 알고리즘 종료 후 연산 횟수 출력
    
[ 구 현 ]

    #include <iostream>
    #include <cstring>
    #include <algorithm>
    #include <queue>
    #include <utility>
    #include <vector>

    using namespace std;
    int N, M;
    int B[50];
    int main() {
        ios::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        //freopen("Input.txt","r", stdin);

        cin >> N;
        for (int a = 0; a < N; ++a) {
            cin >> B[a];
        }
        int answer = 0;
        while (1) {
            bool zero = 1; // 배열의 모든값이 0인지 확인하는 변수
            bool judge = 1; 
            // 두배로 하는 연산이 필요한지(B배열의 값을 반으로 나누는 연산)확인

            for (int a = 0; a < N; ++a) {
                if (B[a]) // 배열의 원소가 하나라도 0이 아니면 
                    zero = 0; // zero는 불가능

                if (B[a] % 2) { // 2로 나누었을때 1이라면(홀수가 아니라면)
                    ++answer; // 조건 1 연산 1회 수행
                    
                    judge = 0; // 반으로 나누는 연산 미루기
                    
                    B[a] -= 1; // 현재 원소의 값 1 빼기
                }
            }

            if (zero) // 모든값이 0이라면
                break; // while문 종료

            if (judge) { // 모든값이 2의 배수라면
                for (int a = 0; a < N; ++a) {
                    B[a] /= 2;
                } // 조건 2 연산 후
                ++answer; // 연산횟수 1회 증가
            }

        }
        cout << answer;

        return 0;

    }
