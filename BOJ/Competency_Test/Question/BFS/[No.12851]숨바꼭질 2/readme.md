문제 사이트 : https://www.acmicpc.net/problem/12851

문제 설명 :

    수빈이는 동생과 숨바꼭질을 하고 있다. 
    
    수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 
    
    수빈이는 걷거나 순간이동을 할 수 있다. 
    
    만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다.
    
    순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

    수빈이와 동생의 위치가 주어졌을 때, 
    
    수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 
    
    가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.

입력

      첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

출력

    첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

    둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.

예제 입력 1 

    5 17

예제 출력 1 

    4
    2
    
풀이 알고리즘

    BFS탐색 알고리즘으로 해결할 수 있는 문제 '숨바꼴질 2'입니다.
    
    문제풀이 초기에 단순 bfs로 배열에 특정위치에 도달했을 때, 도달한 시간을 입력하여 문제를 해결하려고 햇는데
    
    시간초과가 발생하였고, boolean타입으로 한 결과 시간이 단축되어서 해결할 수 있었습니다.
    
    바로 풀이로 들어가겠습니다.
    
    1.(입력) N과 K를 입력받습니다.
    
    2.(풀이) 만약 N이 K보다 크다면 수빈이는 N-K번 뒷걸음질 했을 경우에만 동생에게 도달할 수 있으므로
    
    N-K 시간동안 걸려서 1가지 경우의 수로 동생과 만날 수 있습니다.
    
    3. (풀이) 2번 케이스가 아니라면 다음과 같은 동작을 반복합니다.
    
          1) 현재 위치에서 한칸 이동한 위치가 해당 위치까지 최단시간이라면 이동.
          2) 현재 위치에서 한칸 뒤로간 위치가 해당 위치까지 최단시간이라면 이동
          3) 현재 위치 * 2 한 위치가 해당 위치까지 최단시간이라면 이동.
          
    4. (풀이) 3의 동작 과정에서 같은 곳을 방문할 수 있으므로, 방문표시는 별개로 하지않고 현재 초에 가능한 모든 이동에 대하여
    
        이동을 수행한 이후 다음초에서 해당 위치를 기준으로 3번 과정을 진행할 때 방문표시를 하여 해당 위치를 재방문 하지 않도록
        
        합니다.
        
    5. (정답) 만약 3번 과정중에 목적지 K에 도달한 경우가 있다면 도달할때마다 경우의수를 추가해주고
    
        해당 초에 이동가능한 모든 케이스를 종료 후 현재 시간과 경우의수를 출력합니다.
   
   
풀이 인증샷

![image](https://user-images.githubusercontent.com/57944215/218474178-83277ecc-7a2c-4640-98da-f54fef321cae.png)
        
