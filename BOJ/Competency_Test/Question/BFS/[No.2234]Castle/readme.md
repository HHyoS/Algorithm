문제 사이트 : https://www.acmicpc.net/problem/2234

문제 설명 :  

	대략 위의 그림과 같이 생긴 성곽이 있다.
	
	굵은 선은 벽을 나타내고, 점선은 벽이 없어서 지나다닐 수 있는 통로를 나타낸다. 
	
	이러한 형태의 성의 지도를 입력받아서 다음을 계산하는 프로그램을 작성하시오.

	이 성에 있는 방의 개수
	
	가장 넓은 방의 넓이
	
	하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기
	
	위의 예에서는 방은 5개고, 가장 큰 방은 9개의 칸으로 이루어져 있으며, 위의 그림에서 화살표가 가리키는 
	
	벽을 제거하면 16인 크기의 방을 얻을 수 있다.

	성은 m×n(1 ≤ m, n ≤ 50)개의 정사각형 칸으로 이루어진다. 성에는 최소 두 개의 방이 있어서, 항상 하나의 벽을 제거하여 두 방을 합치는 경우가 있다.

입력

	첫째 줄에 두 정수 n, m이 주어진다. 다음 m개의 줄에는 n개의 정수로 벽에 대한 정보가 주어진다. 
	
	벽에 대한 정보는 한 정수로 주어지는데, 서쪽에 벽이 있을 때는 1을, 북쪽에 벽이 있을 때는 2를, 동쪽에 벽이 있을 때는 4를, 남쪽에 벽이 있을 때는 8을 더한 값이 주어진다.
	
	참고로 이진수의 각 비트를 생각하면 쉽다. 따라서 이 값은 0부터 15까지의 범위 안에 있다.

출력

	첫째 줄에 1의 답을, 둘째 줄에 2의 답을, 셋째 줄에 3의 답을 출력한다.

예제 입력 

	1 
	7 4
	11 6 11 6 3 10 6
	7 9 6 13 5 15 5
	1 10 12 7 13 7 5
	13 11 10 8 10 12 13
	
예제 출력 1 

	5
	9
	16

코드 및 설명

	#include <iostream>
	#include <cstdio>
	#include<string.h>
	#include<algorithm>

	using namespace std;

	int mp[51][51];
	bool ar[51][51];


	int n, m; // 입력받을 변수
	int biggerst = 0; // 가장 큰 방 크기
	int ck = 0;  // 현재  탐색중인 방 크기 확인
	int arr[4] = { 1,2,4,8 }; // 벽의 위치를 확인하는 배열
	void bfs1(int x,int y){ // 연결된 방을 탐색하는 bfs탐색
		++ck;
		for (int a = 0; a < 4; ++a) { 
			if ((mp[x][y] & arr[a]) != arr[a]) { // 서 북 동 남 벽의 위치를 확인하고 벽이 존재하지 않는다면 -
				if ((arr[a] == 1) && (y > 1)){  // 서쪽 벽이 존재하지 않는 위치가 이동 가능한 위치(주어진 범위를 벗어났는지)인지 확인
					if (!ar[x][y-1]) { // 방문한 적이 없다면
						ar[x][y-1] = 1; // 방문 체크 후 
						bfs1(x, y-1); // bfs탐색
					}

				}
				else if ((arr[a] == 2) && (x > 1)) { // 북쪽
					if (!ar[x-1][y]) {
						ar[x - 1][y] = 1;
						bfs1(x - 1, y);
					}

				}
				else if ((arr[a] == 4) && (y < n)) { // 동쪽
					if (!ar[x][y+1]) {
						ar[x][y+1] = 1;
						bfs1(x, y+1);
					}

				}
				else if ((arr[a] == 8) && (x < m)) { // 남쪽
					if (!ar[x + 1][y]) {
						ar[x + 1][y] = 1;
						bfs1(x + 1, y);
					}
				}
			}
		}
	}

	int main(){

	//	freopen("Input.txt", "r", stdin);
		cin >> n >> m ;


		for (int a = 1; a <= m; ++a) { // 벽의 위치를 입력받고
			for (int b = 1; b <= n; ++b) {
				cin >> mp[a][b];
			}
		}
		int room = 0;
		for (int a = 1; a <= m; ++a) { // 방의 갯수와 최대 크기의 방을 찾는 bfs탐색 실시
			for (int b = 1; b <= n; ++b) {
				if (!ar[a][b]) {
					ck = 0;
					ar[a][b] = 1;
					bfs1(a, b);
					if (ck > biggerst)
						biggerst = ck;
					++room;
				}
			}	
		}
		cout << room << " " << biggerst; // 방의 갯수와 벽을 뚫지 않았을 때 가장 큰 방의 크기 출력
		for (int a = 1; a <= m; ++a) {
			for (int b = 1; b <= n; ++b) {
				for (int c = 0; c < 4; ++c) {
					if ((mp[a][b] & arr[c]) == arr[c]) { // 110~111 line은 2중 for문을 통해 모든 위치에서 부실 수 있는 벽을 확인하고 벽을 부시는 행위를 수행
						memset(ar, 0, sizeof(ar)); // 모든 방향에서 수행해야 하므로 주기적으로 메모리 초기화 실시
						ck = 0;
						ar[a][b] = 1;
						mp[a][b] -= arr[c]; // 벽을 부셨으므로 벽 부신거 체크
						bfs1(a, b);
						if (ck > biggerst)
							biggerst = ck;
						mp[a][b] += arr[c]; // 부신 벽 복구
					}
				}
			}
		}
		cout << " "<< biggerst;
		return 0;
	}

설명 

주어진 조건에 맞추어 다음의 세가지를 출력해야하는 문제였습니다.

	  조건 1 이 성에 있는 방의 개수
	  조건 2 가장 넓은 방의 넓이
	  조건 3 하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기

이 문제 풀이의 가장 중요한 것은 벽의 위치를 파악하는 방법을 생각해내는것 이였습니다.

벽의 위치가 1, 2, 4, 8 이 더해진 형태로 주어졌기 때문에, 1, 2, 4 ,8 과 & 연산을 통해 벽의 위치를 파악하는 방법을 사용하였고, 

1번과 2번을 해결할 때에는 다음의 순서를 알고리즘으로 구현하여 해결하였습니다.

	  1. 방문하지 않은 방 찾기
	  2. 찾은 방을 기준으로 bfs탐색 실시
	  3. bfs탐색을 하며 방의 크기 저장(ck변수에)
	  4. bfs탐색이 종료되면 biggerst 변수와 비교하여 가장 큰 방의 크기를 저장(2번 조건)
	  5. (1번 ~ 2번) 을 수행한 횟수를 room 변수에 저장하여 방의 갯수저장(1번 조건)
 
3번 조건의 경우, 모든 방에 대해서 부실 수 있는 벽의 위치를 확인하고, 부실 수 있는 벽이라면 부신 후 bfs탐색을 통해 가장 큰 방의 크기를 찾아 출력하는 조건이였습니다.

해당 조건을 만족하기위해 모든 방에 부실수 있는 벽의 위치를 확인하고, 해당 방을 시작으로 bfs탐색을 시작하는 방법을 사용했습니다.

108~ 123 line의 3중for문과 if문

	for (int a = 1; a <= m; ++a) {
		for (int b = 1; b <= n; ++b) {
			for (int c = 0; c < 4; ++c) {
				if ((mp[a][b] & arr[c]) == arr[c]) {
          
                                            
을 통해 벽의 위치를 확인하였고, 벽이 있는것이 확인되면 해당 벽을 부시는 memset함수를 통해 모든 방문기록을 초기화하고, mp[a][b] 변수에 arr[c]값을 빼주어 벽이 없는것으로 처리한 뒤 bfs탐색을 진해하여습니다.
        
bfs탐색 이후에는 mp[a][b] 변수에 다시 arr[c] 값을 더해주어 벽을 재생성 하고, 이런 사이클을 모든 방에 대해서 탐색을 진행하여 문제를 해결하였습니다.

