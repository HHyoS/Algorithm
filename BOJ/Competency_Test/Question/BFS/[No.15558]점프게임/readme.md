문제 사이트 : https://www.acmicpc.net/problem/15558

문제 설명 :

![1](https://user-images.githubusercontent.com/57944215/218257117-5651fd86-0171-47a9-b81f-504c8c58d6ea.png)

상근이는 오른쪽 그림과 같은 지도에서 진행하는 게임을 만들었다.

지도는 총 2개의 줄로 나누어져 있으며, 각 줄은 N개의 칸으로 나누어져 있다. 칸은 위험한 칸과 안전한 칸으로 나누어져 있고, 안전한 칸은 유저가 이동할 수 있는 칸, 위험한 칸은 이동할 수 없는 칸이다.

가장 처음에 유저는 왼쪽 줄의 1번 칸 위에 서 있으며, 매 초마다 아래 세 가지 행동중 하나를 해야 한다.

    (1) 한 칸 앞으로 이동한다. 예를 들어, 현재 있는 칸이 i번 칸이면, i+1번 칸으로 이동한다.
    
    (2) 한 칸 뒤로 이동한다. 예를 들어, 현재 있는 칸이 i번 칸이면, i-1번 칸으로 이동한다.
    
    (3) 반대편 줄로 점프한다. 이때, 원래 있던 칸보다 k칸 앞의 칸으로 이동해야 한다. 
         예를 들어, 현재 있는 칸이 왼쪽 줄의 i번 칸이면, 오른쪽 줄의 i+k번 칸으로 이동해야 한다.
    
    (4) N번 칸보다 더 큰 칸으로 이동하는 경우에는 게임을 클리어한 것이다.

게임을 재밌게 하기 위해서, 상근이는 1초에 한 칸씩 각 줄의 첫 칸이 사라지는 기능을 만들었다. 즉, 게임을 시작한지 1초가 지나면 1번 칸이 사라지고, 2초가 지나면 2번 칸이 사라진다. 편의상 유저가 먼저 움직이고, 칸이 사라진다고 가정한다. 즉, 이번에 없어질 칸이 3번 칸인데, 상근이가 3번 칸에 있다면, 3번 칸에서 다른 칸으로 이동하고 나서 3번 칸이 없어지는 것이다.

각 칸의 정보가 주어졌을 때, 게임을 클리어 할 수 있는지, 없는지 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 N과 k가 주어진다. (1 ≤ N, k ≤ 100,000)

    둘째 줄에는 왼쪽 줄의 정보가 주어진다. i번째 문자가 0인 경우에는 위험한 칸이고, 1인 경우에는 안전한 칸이다. 셋째 줄에는 오른쪽 줄의 정보가 주어지고, 각 문자의 의미는 왼쪽 줄의 의미와 동일하다.

    왼쪽 줄의 1번 칸은 항상 안전한 칸이다.

출력

    게임을 클리어할 수 있으면 1을, 없으면 0을 출력한다.

예제 입력 1 

    7 3
    1110110
    1011001

예제 출력 1 

    1

예제 입력 2 

    6 2
    110101
    011001

예제 출력 2 

    0 
    
    
풀이 알고리즘

      주어진 조건에 맞는 동작을 했을 때, 게임을 클리어 할 수 있는지 결과를 출력하는 문제 '점프 게임' 입니다.
      
      문제의 조건은 단순합니다. (1) 현재 줄에서 +1 전진, (2) 옆의 줄의 현재위치 + K 위치로 점프 (3) 현재 줄의 -1 후진
      
      위의 조건으로 문제를 해결 할 때 주의해할 점들은 다음과 같습니다.
      
      (1) 시간에 따라 줄이 사라지므로, 이동할 칸 혹은 현재 위치가 삭제된 줄보다 앞이여야함.
      
      (2) 모든칸이 이동가능한 칸 일경우 -1 +1 의 이동으로 무의미한 이동이 발생하므로, 방문했던 위치는 재방문 하지 않도록 처리
      
      (3) 만약 게임클리어가 가능하다면 바로 끝내서 불필요한 연산 줄이기
      
      풀이 방법 입니다.
      
      (1) (입력) N과 K 그리고 줄의 정보를 입력받습니다
      
      (2) (풀이) 현재 줄의 위치(left of right)와 위치(index)를 가진 구조체를 사용하는 queue를 선언하여 0,0 ( 왼쪽줄, 0번 index)
      
      넣어주기, 시간 초기값은 0
      
      (3) (풀이) 현재 초에 이동가능한 모든 움직임에 대하여 1) 다른줄 + N칸전진 2) 현재줄 1칸 전진 3) 현재줄 1칸 후진 중
      
      이동 가능한 위치가 있는지 확인하고, 방문했던곳인지 확인한 다음 가능한 곳이면 queue에 넣어주고 방문처리
      
      (4) (풀이) (3) 과정을 진행하면서 현재 사라진 줄보다 뒤로가려고하면 스킵
      
      (5) (풀이) 이동과정에서 N번 인덱스 이상을 방문하는 이동이 발생한다면 바로 return 1 처리해주기
      
      (6) (풀이) 모든 움직임에 대하여 클리어가 불가능하다면 return 0
      
      (7) (출력) return 된 값 출력
      
풀이 인증샷 

![image](https://user-images.githubusercontent.com/57944215/218257492-bdcbfb70-f0f4-4965-9687-220ec0185c53.png)

      
      
      
