문제 사이트 : https://www.acmicpc.net/problem/10026

문제 설명 : 

	적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 
	
	따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.

	크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다.
	
	그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다.
	
	또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)

	예를 들어, 그림이 아래와 같은 경우에

	RRRBB
	GGBBB
	BBBRR
	BBRRR
	RRRRR
	
	적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 
	
	하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)

	그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.

입력

	첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)

	둘째 줄부터 N개 줄에는 그림이 주어진다.

출력

	적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.

예제 입력 1 

	5
	RRRBB
	GGBBB
	BBBRR
	BBRRR
	RRRRR

예제 출력 1 

	4 3

코드 및 주석을 통한 설명

	#include <iostream>
	#include <cstdio>
	#include<string.h>

	using namespace std;

	char ar[101][101]; // 입력받은 색 배열 저장
	bool ck[101][101] = {  0, }; // 방문확인
	int xy[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};
	int n;
	int map = 0;
	void bfs(int x,int y,char w){


		if (ar[x][y] == 'R') // 방문 이후 적록색약 탐색에서 for문사용을 줄이기 위해 추가된 코드
			ar[x][y] = 'G';

		for (int a = 0; a < 4; ++a) { // 상하좌우를 탐색

			if ((x + xy[a][0] > 0) && (x + xy[a][0] <= n) && (y + xy[a][1] > 0) && (y + xy[a][1] <= n)) { // 탐색하는 범위가 입력받는 값을 초과하는지 체크

				if ((ar[x + xy[a][0]][y + xy[a][1]] == w) && (ck[x + xy[a][0]][y + xy[a][1]] == 0)) { // 초과하지 않는다면, 같은색 && 방문했던곳 을 확인

					ck[x + xy[a][0]][y + xy[a][1]] = 1; // 방문 체크
					bfs(x + xy[a][0], y + xy[a][1], w); // 다음 bfs시작
				}

			}

		}
		return;
	}

	int main(){

	//	freopen("Input.txt", "r", stdin);
		scanf("%d", &n);
		int map_1 = 0; // 적록색약 x
		int map_2 = 0; // 적록색약 o
		for (int a = 1; a <= n; ++a) { // 입력
			for (int b = 1; b <= n; ++b) {
				scanf(" %c", &ar[a][b]);
			}
		}

		for (int a = 1; a <= n; ++a) {
			for (int b = 1; b <= n; ++b) {
				if (ck[a][b] == 0) { // 방문 안햇다면~
					ck[a][b] = 1; // 방문체크
					bfs(a, b, ar[a][b]);
					++map_1; // 연결된 하나의 색 사이클이 끝났으니 +1
				}
			}
		}

		for (int a = 1; a <= 100; ++a)
			memset(ck[a], 0, sizeof(bool) * 101); // 재활용을 위한 memset

	/*	for (int a = 1; a <= n; ++a) { // 52~53번줄에서 제대로 배열이 변경되었나 체크 -  주석처리
			for (int b = 1; b <= n; ++b) {
				printf("%c", ar[a][b]);
			}
			printf("\n");
		}*/

		for (int a = 1; a <= n; ++a) { // 적록색약이 보는 색 확인을 위한 탐색시작
			for (int b = 1; b <= n; ++b) {
				if (ck[a][b] == 0) {
					ck[a][b] = 1;
					bfs(a, b, ar[a][b]);
					++map_2;
				}
			}
		}
		printf("%d %d", map_1, map_2);
		return 0;
	}

풀이

  RGB 배열값 이 주어졌을 때 적록색약과, 적록색약이 아닌사람이 보는 색 영역의 갯수를 출력하는 문제였습니다.

  풀이를 위해 생각한 방법은

	  1. BFS탐색을 통해 상,하,좌,우를 확인하고 같은색 이라면 해당 위치에서 bfs탐색시작
	  2. 모든 색 배열에 대해 위의 탐색 실시하여 적록색맹이 아닌 사람의 색 영역 구하기
	  3. 탐색 후 RGB값 중 R 값을 G 값으로 바꾸어 저장하고, 1~2 탐색을 다시 진행하여 적로색맹의 색 영역 구하기

였습니다. 위의 방식을 통해 문제를 풀이하는데 성공했고, 준수한 메모리사용과 실행시간을 얻을 수 있었습니다.

개선점? - 두번의 bfs탐색으로인해 메모리사용이 두배로 사용될것으로 생각되는데, 한번의 bfs탐색으로 적록색맹과 아닌 경우 두가지를 동시에 확인하는 방식으로 알고리즘을 구성한다면 

메모리사용을 반으로 줄일 수 있을것으로 생각됩니다.



