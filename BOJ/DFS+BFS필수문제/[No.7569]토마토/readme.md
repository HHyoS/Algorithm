문제 사이트 : https://www.acmicpc.net/problem/7569

문제 설명 :

    철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다.
    
    토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 
    
    상자들을 수직으로 쌓아 올려서 창고에 보관한다.

![upload acmicpc](https://user-images.githubusercontent.com/57944215/185139268-554253bf-ed31-4854-8eb0-cb7f22ebfb59.jpg)


    창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 
    
    아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 
    
    익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다.
    
    하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다.
    
    대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 
    
    토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 
    
    철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.

    토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 
    
    익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 
    
    그 최소 일수를 구하는 프로그램을 작성하라.
    
    단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

입력

    첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. 
    
    M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다.
    
    단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 
    
    둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 
    
    즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 
    
    각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 
    
    정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 
    
    정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.

    토마토가 하나 이상 있는 경우만 입력으로 주어진다.

출력

    여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.

예제 입력 1 

    5 3 1
    0 -1 0 0 0
    -1 -1 0 1 1
    0 0 0 1 1

예제 출력 1 

    -1

예제 입력 2 

    5 3 2
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0
    0 0 0 0 0
    0 0 1 0 0
    0 0 0 0 0
    
예제 출력 2 

    4

예제 입력 3 

    4 3 2
    1 1 1 1
    1 1 1 1
    1 1 1 1
    1 1 1 1
    -1 -1 -1 -1
    1 1 1 -1
    
예제 출력 3 

    0
    
풀이 알고리즘

    주어진 토마토 판을 바탕으로 연결된 모든 토마토를 숙성시혀 익힌 토마토로 만드는 문제였습니다.
    
    예외적으로 1. 토마토가 없는 경우. 2. 토마토를 모두 익힐 수 없는 경우가 존재하는데 해당 부분은
    
    예외처리르 통해 해결하였습니다.
    
    토마토를 익히는 과정을 설명하기에 코드를 보면서 설명하는것이 더 좋을것이라고 생각되어
    
    코드에 주석을 달면서 설명하도록 하겠습니다.
    
구 현

#include<iostream>
#include<string>
#include<algorithm>
#include<queue>

using namespace std;

struct Tomato {
	int h;
	int x;
	int y;
};
int M, N, H;

int map[101][101][101]; // 토마토의 정보를 입력받는 배열 순서대로 map[높이][세로][가로]를 의미합니다.
queue<Tomato> que; // 익은 토마토의 정보를 담는 queue로 bfs동작을하기위해
  // 토마토 정보를 입력받을 때 익은 토마토의 정보를 push합니다.
  
int total_tomato = 0; // 안 익은 토마토의 갯수를 세는 변수로, 정보를 입력받을 때 갱신되며
  // (1) 익힐 토마토가 없는 경우와 (2) 현재까지 익은 토마토의 갯수 를 파악할 때 쓰입니다.

int mov[6][3] = { {1,0,0},{-1,0,0},{0,-1,0},{0,1,0},{0,0,1},{0,0,-1} };
  // 토마토가 익는 방향을 나타내는 배열로 순서대로
  // 윗칸, 아래칸, 아래, 위, 오른족, 왼쪽 방향을 의미
int bfs() {

	int cnt = 1; // 현재까지 지난 시간의 의미
	while (!que.empty()) {
		
		int size = que.size();

		for (int a = 0; a < size; ++a) {
			int h = que.front().h;
			int x = que.front().x;
			int y = que.front().y;
			que.pop();

			for (int b = 0; b < 6; ++b) { // 여섯 방향에 안익은 토마토가 있는지 확인하고 익히는 동작
				int hh = h + mov[b][0];
				int xx = x + mov[b][1];
				int yy = y + mov[b][2];

				if (hh >= 0 && hh < H && xx >= 0 && xx < N && yy >= 0 && yy < M && map[hh][xx][yy] == 0) {
					que.push({ hh,xx,yy }); // 현재 위치가 안익힌 토마토라면 익히고 다음 탐색에 넣기
					map[hh][xx][yy] = 1;
					--total_tomato; // 토마토가 한 개 익었으므로, 안익은 토마토 하나 줄이기
				}
			}
		}
		if (total_tomato == 0) // 한 사이클을 돌았을 떄, 토마토가 모두 익었다면
			return cnt; // 현재 현재까지 지난시간 return
		++cnt; // 아직 안익은 토마토가 남아있으므로 while동작 전 시간 증가
	}

	return -1; // 모두 돌았는데도 total_tomato가 남아있으므로 모두 익히기 불가
}
void input() {
	cin >> M >> N >> H;

	for (int a = 0; a < H; ++a) {
		for (int b = 0; b < N; ++b) {
			for (int c = 0; c < M; ++c) {
				cin >> map[a][b][c];
				if (map[a][b][c] == 0) {
					++total_tomato;
				}
				else if (map[a][b][c] == 1) {
					que.push({ a,b,c, });
				}
			}
		}
	}
	if (total_tomato == 0) {
		cout << 0;
	}
	else {
		cout << bfs();
	}
}
int main()
{
	ios::sync_with_stdio(false);

	cin.tie(NULL);
	cout.tie(NULL);

	input();
	return 0;

}

    
    
