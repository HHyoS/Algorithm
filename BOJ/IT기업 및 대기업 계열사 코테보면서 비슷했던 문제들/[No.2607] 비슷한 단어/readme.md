문제 사이트 : https://www.acmicpc.net/problem/2607

문제 설명 :

    영문 알파벳 대문자로 이루어진 두 단어가 다음의 두 가지 조건을 만족하면
    
    같은 구성을 갖는다고 말한다.
    
        두 개의 단어가 같은 종류의 문자로 이루어져 있다.
        같은 문자는 같은 개수 만큼 있다.
        예를 들어 "DOG"와 "GOD"은 둘 다 'D', 'G', 'O' 세 종류의 문자로 이루어져 
        있으며 양쪽 모두 'D', 'G', 'O' 가 하나씩 있으므로 이 둘은 같은 구성을 갖는다. 
        하지만 "GOD"과 "GOOD"의 경우 "GOD"에는 'O'가 하나, "GOOD"에는 'O'가 
        두 개 있으므로 이 둘은 다른 구성을 갖는다.
        
    두 단어가 같은 구성을 갖는 경우, 또는 한 단어에서 한 문자를 더하거나, 
    빼거나, 하나의 문자를 다른 문자로 바꾸어 나머지 한 단어와 같은 구성을 갖게 
    되는 경우에 이들 두 단어를 서로 비슷한 단어라고 한다.
    
    예를 들어 "DOG"와 "GOD"은 같은 구성을 가지므로 이 둘은 비슷한 단어이다. 
    또한 "GOD"에서 'O'를 하나 추가하면 "GOOD" 과 같은 구성을 갖게 되므로 
    이 둘 또한 비슷한 단어이다. 하지만 "DOG"에서 하나의 문자를 더하거나, 빼거나,
    바꾸어도 "DOLL"과 같은 구성이 되지는 않으므로 "DOG"과 "DOLL"은 비슷한 단어가 아니다.
    
    입력으로 여러 개의 서로 다른 단어가 주어질 때, 
    첫 번째 단어와 비슷한 단어가 모두 몇 개인지 찾아 출력하는 프로그램을 작성하시오.

입력

    첫째 줄에는 단어의 개수가 주어지고 둘째 줄부터는 한 줄에 하나씩 단어가 주어진다. 
    
    모든 단어는 영문 알파벳 대문자로 이루어져 있다. 
    
    단어의 개수는 100개 이하이며, 각 단어의 길이는 10 이하이다.

출력

    입력으로 주어진 첫 번째 단어와 비슷한 단어가 몇 개인지 첫째 줄에 출력한다.

예제 입력 1 

    4
    DOG
    GOD
    GOOD
    DOLL
    
예제 출력 1 

    2

풀이 알고리즘

    타겟 단어와 그 외의 단어들이 주어질 때, 주어진 단어와 '비슷한 단어'가 있는지
    
    확인하고 그 개수를 출력하는 문제 '비슷한 단어' 입니다.

    문제의 조건과 출력은 심플하지만 어떤 케이스에서 '비슷한 단어'가 될 수 있는지

    구분하여 풀이가 필요한 문제 였습니다.

    '비슷한 단어'는 타겟 단어와 알파뱃의 차이가 한개만큼 다르거나, 한개만큼 더 있거나

    한개가 덜 있거나, 동일한 알파뱃 + 횟수 사용 이면 '비슷한 단어'입니다.

    단순하게 접근할 경우, 타겟 단어가 알파뱃을 몇번 썻는지 확인하고, 그 외의 단어들의

    알파뱃 사용 횟수를 확인하여 1 만큼 차이가 나면 비슷한 단어로 취급할 수 있습니다.

    하지만 실제 '비슷한 단어'는 아래의 구분을 가져야 합니다.

    1) 타겟과 동일한 알파뱃 사용 + 동일 횟수 사용 = 비슷한 단어

    2) 타겟과 다른 단어 길이 + 알파뱃 사용 1만큼 차이 = 비슷한 단어

    3) 타겟과 동일한 단어 길이 + 알팝샛 사용 2만큼 차이 = 비슷한 단어

    1)의 경우 당연한 내용이지만 2번과 3번의 경우 실제 계산을 해보지 않으면 이해가 어려울 수

    있습니다.

    단어의 길이가 다를 경우 길이가 작을 때는 타겟과 동일한 단어사용 + 길이 1작음 이여야 하고

    단어의 길이가 길 경우 (타겟 단어와 동일한 알파뱃 + 동일한 횟수 사용) + 임의의 알파뱃 1개

    이면 2번 조건을 만족합니다.

    ex) target = DOG // other = DO / DG / OG / DOGG / DOGZ / GODZ

    길이가 같은 케이스에서 '비슷한 단어'일 경우 반드시 알파뱃 두개 차이가 나게 되는데

    target = DOG 일 경우 / 유사한 단어인 DOZ 를 예시로 들면

    G가 1개만큼, Z가 1개만큼 차이가 나게 됩니다.

    위의 규칙은 단어의 길이가 동일한 케이스에 모두 해당되며 길이가 다를 때와 다른

    예외 처리가 필요합니다.

    위 내용을 코드로 구현하면 아래와 같습니다.

풀이 코드

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <memory.h>
#include <string>
using namespace std;

    /*
        비슷한 단어 조건
        1) 같은 구성 = 동일한 알파뱃 + 동일 횟수 사용
        2) 비슷한 구성 = 단 하나의 알파뱃만 차이
    
        문제 풀이의 방향을 알파뱃 사용 갯수의 차이를 계산하여 풀이하는 것으로 잡는다면
        ex) DOG = D(1) O(1) G(1) 이고, DOGG = D(1) O(1) G(2) = G 한개 차이
        문자의 길이가 다르다면 위와 같이 풀이 가능하지만
        문자의 길이가 같다면
        DOG = D(1) O(1) G(1) / DOZ = D(1) O(1) Z(1) 이므로
        Z(1) G(1) 두개 차이가 발생함.
    
        따라서 하나만 차이가 난다는 것은 두가지로 나누어 생각이 필요
        [1] 동일한 길이 = 차이가 두개 발생했을 때, 유사한 단어
        [2] 다른 길이 = 차이가 하나 발생했을 때, 유사한 단어
    */
    int N;
    int alpha[27];
    vector<string> word;
    int checker[27];
    void Solve() {
        int ans = 0;
        for (int a = 1; a < word.size(); ++a) {
            memset(checker, 0, sizeof(checker));
            for (int b = 0; b < word[a].size(); ++b) {
                int idx = word[a][b] - 'A';
                checker[idx]++;
            }
            int different = 0;
            for (int b = 0; b < 27; ++b) { // 알파뱃 사용 갯수 차이값 구하기
                different += abs(checker[b] - alpha[b]);
            }
            // 동일한 단어거나 or 단어의 길이가 다르지만 딱 한개만 차이나거나
            // or 동일한 길의 단어지만 알파뱃 하나가 차이나거나
            if (different == 0 || different == 1 || (word[0].size() == word[a].size() && different == 2)) {
                ++ans;
            }
        }
        cout << ans;
    }
    void Input() {
        cin >> N;
        for (int a = 0; a < N; ++a) {
            string temp;
            cin >> temp;
            word.push_back(temp);
        }
        for (int a = 0; a < word[0].size(); ++a) {
            alpha[word[0][a] - 'A']++;
        }
    }
    int main() {
        ios::sync_with_stdio(false);
    
        cin.tie(NULL);
        cout.tie(NULL);
        Input();
        Solve();
        return 0;
    }

풀이 후기

    문제를 풀 때는 생각 못했는데, 맘대로 TC를 만들어서 넣다보니까 생각이 나버린 문제 ㄴㅇㄱ

    실버 2중에 쉬운 편에 속하는 문제로 맛있게 풀었다
![image](https://github.com/user-attachments/assets/d0660548-9780-448c-a7df-874e1a2ef8d1)

