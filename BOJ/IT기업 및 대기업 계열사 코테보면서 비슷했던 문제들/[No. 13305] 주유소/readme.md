문제 사이트 : https://www.acmicpc.net/problem/13305

문제 설명 :

    어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다.
    
    편의상 일직선을 수평 방향으로 두자. 
    
    제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 
    
    인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다.
    
    도로 길이의 단위는 km를 사용한다.
    
    처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다.
    
    기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 
    
    도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 
    
    각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다.
    
    가격의 단위는 원을 사용한다.
    
    예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자.
    
    원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 
    
    도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 

![image](https://github.com/user-attachments/assets/20e70330-e4bb-4842-8584-38dc34c0f0f6)


    제일 왼쪽 도시에서 6리터의 기름을 넣고, 
    
    더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 
    
    만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 
    
    다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 
    
    1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다.
    
    또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 
    
    다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 
    
    총 비용은 18원이다.
    
    각 도시에 있는 주유소의 기름 가격과, 
    
    각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 
    
    제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.

입력

    표준 입력으로 다음 정보가 주어진다.
    
    첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다.
    
    다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가
    
    제일 왼쪽 도로부터 N-1개의 자연수로 주어진다.
    
    다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 
    
    도시부터 순서대로 N개의 자연수로 주어진다.
    
    제일 왼쪽 도시부터 제일 오른쪽 도시까지의 
    
    거리는 1이상 1,000,000,000 이하의 자연수이다. 
    
    리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다. 

출력

    표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다. 

예제 입력 1 

    4
    2 3 1
    5 2 4 1

예제 출력 1 

    18

예제 입력 2 

    4
    3 3 4
    1 1 1 1

예제 출력 2 

    10

풀이 알고리즘

    각 도시별 주유소 기름 값이 주어졌을 때, 최소 비용으로 마지막 도시까지 도착하는 문제 입니다.

    문제의 도시 개수가 최대 10만개, 기름 값이 1억으로 int형 처리가 불가능하고

    도시의 개수가 최대 10만개 이므로, dfs로 처리할 경우 back tracking을 사용하더라도

    시간 초과가 발생할 수 있는 문제였습니다.

    문제의 설명이 매우 길지만 단순하게 생각하면, 풀이 방법은 아래와 같습니다.
    
    1) 특정 위치까지 가장 저렴한 기름값을 가진 도시에서 기름 채우기

    2) 현재 도시가 기름 값이 더 싸다면, 현재 도시의 기름 값을 - 저렴이 로 등록하고
    
    이후 방문하는 도시와 비교하여 '저렴이'가 더 싸다면, '저렴이'로 현재 도시까지 온 것으로

    처리하면 됩니다.

    3) 만약 방문한 도시의 기름값이 '저렴이'보다 싸다면, 방문 도시의 기름값을 '저렴이'로 등록하고

    이후 부터는 새로운 '저렴이'와 비교하며 더 싼 기름값이 나올 때 까지 '저렴이'로 기름을

    넣었다 가정하면 됩니다.

    위 풀이방법을 코드로 구현한 내용은 아래와 같습니다.

구현 코드

    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <queue>
    #include <memory.h>
    using namespace std;
    
    
    int N;
    long long leng[100010];
    long long price[100010];
    
    /*풀이 알고리즘
    조건 1 : 최소 비용 사용
    조건 2 : 주행 중 기름이 떨어져서는 안됨 -> 기름의 양은 현재 위치에서 다음 도시로 갈 정도는 되어야 함
    조건 3 : 기름통의 양은 무제한 이므로, 저렴한 곳에서 최대한 채우는게 이득임 
    */
    
    void Solve() {
    
        long long min_cost = price[0]; // 첫번째 도시까지는 현재 처음 위치에서 기름 넣어어 함
        long long total_cost = 0;
    
        for (int a = 1; a < N; ++a) {
            total_cost += (min_cost * leng[a]); //일단 현재 도시까지는 '저렴이'로 온 상태고
            if (min_cost > price[a]) { // 현재 도시의 기름값이 더 싸다면
                min_cost = price[a]; // 현재 도시의 기름값이 '저렴이'임
            }

            // 만약 '저렴이'가 가장 싸다면 계속 '저렴이'로 기름을 넣엇다고 가정
        }
        cout << total_cost; // 정답 출력
    }
    void Input() {
        cin >> N;
        for (int a = 1; a < N; ++a) {
            cin >> leng[a];
        }
        for (int a = 0; a < N; ++a) {
            cin >> price[a];
        }
    }
    int main() {
        ios::sync_with_stdio(false);
    
        cin.tie(NULL);
        cout.tie(NULL);
        Input();
        Solve();
    
        return 0;
    }

풀이 후기

    위의 풀이 방법을 생각하지 못해서 한참 고민한 문제 '주유소'...

    dfs로 구현하여 시간과 나오고 난리도 아니다잉..

    이런 간단한 그리디도 생각하지 못하다니 갈길이 멀구먼..

![image](https://github.com/user-attachments/assets/f6f42b8e-b82a-4fc8-9b65-d5b68e7f5e22)
