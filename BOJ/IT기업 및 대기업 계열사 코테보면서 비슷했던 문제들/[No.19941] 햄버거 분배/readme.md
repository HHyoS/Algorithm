문제 사이트 : https://www.acmicpc.net/problem/19941

문제 설명 :

    기다란 벤치 모양의 식탁에 사람들과 햄버거가 아래와 같이 단위 간격으로 놓여 있다. 
    사람들은 자신의 위치에서 거리가 
    K 이하인 햄버거를 먹을 수 있다.

![image](https://github.com/user-attachments/assets/d8495aac-d9cb-4cb9-83f3-c964d92807b6)

    위의 상태에서 K = 1인 경우를 생각해보자.
    
    이 경우 모든 사람은 자신과 인접한 햄버거만 먹을 수 있다.
    
    10번의 위치에 있는 사람은 11번 위치에 있는 햄버거를 먹을 수 있다.
    
    이 경우 다음과 같이 최대 5명의 사람이 햄버거를 먹을 수 있다.

-     2번 위치에 있는 사람: 1번 위치에 있는 햄버거
-     4번 위치에 있는 사람: 5번 위치에 있는 햄버거
-     6번 위치에 있는 사람: 7번 위치에 있는 햄버거
-     9번 위치에 있는 사람: 8번 위치에 있는 햄버거
-     10번 위치에 있는 사람: 11번 위치에 있는 햄버거
-     12번 위치에 있는 사람: 먹을 수 있는 햄버거가 없음
 
$K = 2$인 경우에는 6명 모두가 햄버거를 먹을 수 있다.

-     2번 위치에 있는 사람: 1번 위치에 있는 햄버거
-     4번 위치에 있는 사람: 3번 위치에 있는 햄버거
-     6번 위치에 있는 사람: 5번 위치에 있는 햄버거
-     9번 위치에 있는 사람: 7번 위치에 있는 햄버거
-     10번 위치에 있는 사람: 8번 위치에 있는 햄버거
-     12번 위치에 있는 사람: 11번 위치에 있는 햄버거

    식탁의 길이 N, 햄버거를 선택할 수 있는 거리 K, 사람과 햄버거의 위치가 주어졌을 때, 
    
    햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성하시오.

입력

    첫 줄에 두 정수 N과 K가 있다. 
    그리고 다음 줄에 사람과 햄버거의 위치가 문자 P(사람)와 H(햄버거)로 이루어지는 길이 
    N인 문자열로 주어진다.

출력

    첫 줄에 햄버거를 먹을 수 있는 최대 사람 수를 나타낸다.

제한

    1 <= N <= 20,000
    1 <= K <= 10
    
예제 입력 1 

    20 1
    HHPHPPHHPPHPPPHPHPHP

예제 출력 1 

8

예제 입력 2 
    
    20 2
    HHHHHPPPPPHPHPHPHHHP

예제 출력 2 

    7

풀이 알고리즘

    햄버거와 사람이 섞여있는 입력값, 그 길이 N, 사람의 손이 도달 가능한 거리 K가 주어질 때

    햄버거를 먹을 수 있는 사람의 최대 인원을 구하는 문제 '햄버거 분배' 입니다.

    위 문제를 풀 때 베이스로 준비 해야하는 개념은, 제한된 거리 내에서 최대 인원이

    햄버거를 먹기 위해서는 다른 사람 기준 가장 먼 햄버거를 현재 사람이 먹어야 한다는 것

    입니다.

    위 내용을 좀 더 정리하자면 입력값을 좌에서 우로 탐색( -> 방향 )으로 한다고 하면

    처음 사람을 골랐을 때, 왼쪽에 있는 햄버거 중 가장 먼 햄버거가
    
    타인 기준 가장 먼 햄버거고 오른쪽 햄버거 중 가장 가까운 햄버거가 타인 기중 가장 먼

    햄버거입니다.

    따라서 탐색 방향을 정했을 때, 햄버거 인덱스에 접근하게 되면 K거리 내에 사람을 찾아 매칭해주고

    사람 인덱스에 접근하게되면 K거리 내에 햄버거를 찾아 매칭해주면 위의 논리가 성립하게 됩니다.

    햄버거 기준 : 처음 만난 사람과 매칭 = 타인 기준 가장 먼 햄버거 매칭 완료

    사람 기준 : 오른쪽 가장 가까운 햄버거와 매칭 = 타인 기준 가장 먼 햄버거 매칭 완료

    위 내용을 코드로 구현하면 아래와 같습니다.

풀이 코드

    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <queue>
    #include <memory.h>
    using namespace std;
    
    /*
        문제를 보면 그리디로 보이니까 어떻게 풀지 고민해보자..
        도달 거리가 정해져 있으므로
        타인 기준 가까운 햄버거를 집어야, 최대 사람이 먹을 수 있음
        따라서 맨 앞 혹은 맨 뒤에서 시작하자.
        그리고 시작이 햄버거라면 햄버거 기준 가장 가까운 사람에게 햄버거를 주고
        시작이 사람이라면 가장 가까운 햄버거를 체크해주자
    
    */
    string hambuger;
    int N, K;
    bool eat[20001];
    void Solve() {
        int answer = 0;
        for (int a = 0; a < N; ++a) {
            int checker = 0;
    
            // 이미 먹은 햄버거 or 먹은 사람 스킵
            if (eat[a] == 1) continue;
    
            // K까지의 범위 내에서 현재 인덱스의 상태(햄버거 or 사람)와
            // 다른 인덱스를 찾자
            for (int b = 1; b <= K; ++b) {
                int idx = a + b;
                if (idx >= N) break; // 범위 벗어나면 안되니까 처리해주고
    
                // 만약 찾은 인덱스가 1) 현재 먹히거나 먹은 사람이 아니고
                // 2) 현재 상태(햄버거 or 사람)이 아니여서 먹히거나 먹을 수 있는 관계라면
                // 먹고 정답 +1하고 먹음 처리
                if (eat[idx] == 0 && hambuger[idx] != hambuger[a]) {
                    eat[idx] = 1;
                    ++answer;
                    break;
                }
            }
        }
        cout << answer;
    }
    void Input() {
        cin >> N >> K;
        cin >> hambuger;
    
    }
    int main() {
        ios::sync_with_stdio(false);
    
        cin.tie(NULL);
        cout.tie(NULL);
        Input();
        Solve();
        return 0;
    }

풀이 후기

    간단한 그리디 문제구만

    1일 1커밋을 위해 다른 문제를 피해 도망쳤지만 나쁘지 않았따..

    내일은 그 녀석을 이기고 오겠다
    
![image](https://github.com/user-attachments/assets/5f75fd83-1142-4562-b3a5-155503144701)


    
