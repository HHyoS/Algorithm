문제 사이트 : https://www.acmicpc.net/problem/1205

문제 설명

    태수가 즐겨하는 디제이맥스 게임은 각각의 노래마다 랭킹 리스트가 있다. 
    
    이것은 매번 게임할 때 마다 얻는 점수가 비오름차순으로 저장되어 있는 것이다.
    
    이 랭킹 리스트의 등수는 보통 위에서부터 몇 번째 있는 점수인지로 결정한다.
    
    하지만, 같은 점수가 있을 때는 그러한 점수의 등수 중에 가장 작은 등수가 된다.
    
    예를 들어 랭킹 리스트가 100, 90, 90, 80일 때 각각의 등수는 1, 2, 2, 4등이 된다
    
    랭킹 리스트에 올라 갈 수 있는 점수의 개수 P가 주어진다. 
    
    그리고 리스트에 있는 점수 N개가 비오름차순으로 주어지고, 태수의 새로운 점수가 주어진다.
    
    이때, 태수의 새로운 점수가 랭킹 리스트에서 몇 등 하는지 구하는 프로그램을 작성하시오. 
    
    만약 점수가 랭킹 리스트에 올라갈 수 없을 정도로 낮다면 -1을 출력한다.
    
    만약, 랭킹 리스트가 꽉 차있을 때, 새 점수가 이전 점수보다 더 좋을 때만 점수가 바뀐다.

입력

    첫째 줄에 N, 태수의 새로운 점수, 그리고 P가 주어진다. P는 10보다 크거나 같고,
    
    50보다 작거나 같은 정수, N은 0보다 크거나 같고, P보다 작거나 같은 정수이다.
    
    그리고 모든 점수는 2,000,000,000보다 작거나 같은 자연수 또는 0이다. 
    
    둘째 줄에는 현재 랭킹 리스트에 있는 점수가 비오름차순으로 주어진다.
    
    둘째 줄은 N이 0보다 큰 경우에만 주어진다.

출력

    첫째 줄에 문제의 정답을 출력한다.

예제 입력 1 

3 90 10
100 90 80

예제 출력 1 

2
10 1 10
10 9 8 7 6 5 4 3 2 1

예제 출력 2 

  -1

예제 입력 3 

    10 1 10
    10 9 8 7 6 5 4 3 3 0

예제 출력 3 

    10

예제 입력 4 

    0 0 50

예제 출력 4 

    1

풀이 알고리즘

    정해진 조건에 따라 구현하여 문제의 주인공인 태수의 등수를 찾는 문제입니다.

    주어진 조건에 대해 잘 읽어야 하는 문제로, 아래 조건들을 확인해야 합니다.

    1) N은 0 <= P 

     N=0인 케이스가 있다는 조건으로, N이 0이라면 태수는 항상 1등 입니다.

    2) P는 N보다 작을 수 있다.

    P가 N보다 작을 수 있다는 조건은 태수가 두 가지 등수를 가질 수 있게 하는 조건으로

    N개의 점수 중 태수가 더 큰 점수가 존재한다면 해당 등수가 태수의 등수가 되고, 아니라면

    N+1이 태수의 등수가 됩니다,

    3) 새 점수가 이전 점수보다 더 좋을 때만 점수가 바뀐다.

    태수의 점수가 랭킹 내의 누군가와 점수가 동일하더라도, 상위 랭킹 인원 + 동일 점수 인원이

    P보다 크다면 태수의 랭킹은 등록될 수 없습니다.

    4) 위의 조건을 제외하고는 태수가 점수가 높다면 등수 세팅, 아니라면 등외가 됩니다.

    위의 조건대로 구현을 진행하면 아래의 코드가 됩니다.
    
풀이 코드

    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <queue>
    using namespace std;
    
    int N, S, P; // N=점수 개수, S=태수점수, P=랭킹 가능 개수
    priority_queue<int> que;
    int Solve() {
        int rank = 1;
        int cnt = 0;
        int ans = -1;
        if (N == 0) // 1번 조건 N이 0이면 P는 항상 10 이상이므로 1등
            return 1;
        while (!que.empty()) {// 우선순위 que에서 꺼내면서 4번 조건에 맞는 결과값 찾기
            int now_score = que.top();
            que.pop();
            ++cnt;
            if (now_score > S) { // 우선순위 큐의 숫자가 크면 다음으로 넘기기
                rank = cnt+1;
            }
            else if (now_score == S) { // 3번 조건 찾는 조건문
                while (!que.empty() && que.top() == now_score) { // 동일 등수가 몇명인지 체크
                    now_score = que.top();
                    que.pop();
                    ++cnt;
                }
                if (cnt < P) { // 동일 등수를 다 합쳤을 때, 랭킹 범위 내에 들어온다면
                    ans = rank; // 랭킹은 모두 동일 랭킹으로 세팅
                }
                break;
            }
            else { // if(now_score < S) // 현재 점수보다 크다면, 내 위치 정해주기
                ans = rank;
                break;
            }
        }
        if (N < P && ans == -1) { // 2번 조건
        // 만약 등수가 정해지지 않았는데, 모든 큐의 값을 다 뺏다면
            return N + 1; // 현재 등록된 랭킹 +1이 내 랭킹
        }
        return ans;
    }
    void Input() {
        cin >> N >> S >> P;
        for (int a = 0; a < N; ++a) {
            int temp;
            cin >> temp;
            que.push(temp);
        }
    }
    int main() {
        ios::sync_with_stdio(false);
    
        cin.tie(NULL);
        cout.tie(NULL);
        Input();
        cout << Solve();
    
    
        return 0;
    }

풀이 후기

    문제의 함정에 빠져버려 반례를 열심히 찾아야 했던 문제 '등수 구하기'..

    일찍 자고 싶은 마음에 자꾸 문제를 덜 보는데 앞으로는 5분이상 문제 정독을 해야겠다..

![image](https://github.com/user-attachments/assets/e7ac92bf-4048-4e8b-8e3b-b1720fe6bcb7)
