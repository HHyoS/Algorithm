문제 사이트 : https://www.acmicpc.net/problem/10875

문제 설명 :

    가로 길이와 세로 길이가 모두 2L + 1인 2차원 격자판이 있다. 
    
    이 격자판의 각 칸을 그 좌표에 따라 (x, y)로 표현하기로 한다. 
    
    격자판의 가운데 칸의 좌표는 (0, 0)이고, 맨 왼쪽 맨 아래 칸의 좌표는 (−L, −L), 그리고 맨 오른쪽 맨 위 칸의 좌표는 (L, L)이다.
    
    x좌표는 왼쪽에서 오른쪽으로 갈수록, y좌표는 아래에서 위로 갈수록 증가한다.

![snake_start](https://user-images.githubusercontent.com/57944215/209438887-eaa83c14-9229-4b1b-b1cc-f48ca530db0d.png)

    이 격자판의 (0, 0) 칸에 한 마리의 뱀이 자리를 잡고 있다. 
    
    처음에는 뱀의 크기가 격자판의 한 칸의 크기와 같으며, 뱀의 머리는 격자판의 오른쪽을 바라보고 있다. 
    
    이 뱀은 자신이 바라보고 있는 방향으로 1초에 한 칸씩 몸을 늘려나가며, 뱀의 머리는 그 방향의 칸으로 옮겨가게 된다. 
    
    예를 들어 위의 그림과 같이 L = 3인 경우를 생각해 보자. 뱀은 처음에 (0, 0)에 있으며, 그 크기는 격자판 한 칸 만큼이고, 
    
    뱀의 머리가 바라보고 있는 방향은 오른쪽이다. 
    
    1초가 지나고 나면 이 뱀은 몸을 한 칸 늘려서 (0, 0)과 (1, 0)의 두 칸을 차지하게 되며, 이때 (1, 0) 칸에 뱀의 머리가 놓이게 된다. 
    
    1초가 더 지나고 나면 (0, 0), (1, 0), (2, 0)의 세 칸을 차지하게 되고, 뱀의 머리는 (2, 0)에 놓이게 된다.

    이 뱀은 자신의 머리가 향하고 있는 방향을 일정한 규칙에 따라 시계방향, 혹은 반시계방향으로 90도 회전한다. 
    
    1번째 회전은 뱀이 출발한지 t1 초 후에 일어나며 i(i > 1)번째 회전은 i − 1번째 회전이 끝난 뒤 ti 초 후에 일어난다.
    
    단, 뱀은 ti 칸 만큼 몸을 늘린 후에 머리를 회전하며 머리를 회전하는 데에는 시간이 소요되지 않는다고 가정한다.

    만일 뱀의 머리가 격자판 밖으로 나가게 되면, 혹은 뱀의 머리가 자신의 몸에 부딪히게 되면 이 뱀은 그 즉시 숨을 거두며 뱀은 숨을 거두기 직전까지 몸을 계속 늘려나간다.

    뱀이 머리를 회전하는 규칙, 즉 ti 와 그 방향에 대한 정보가 주어졌을 때, 뱀이 출발한지 몇 초 뒤에 숨을 거두는지를 알아내는 프로그램을 작성하라.

입력

    첫 번째 줄에 정수 L(1 ≤ L ≤ 108)이 주어진다. 두 번째 줄에는 머리의 방향을 몇 번 회전할 것인지를 나타내는 정수 N(0 ≤ N ≤ 103)이 주어진다. 
    
    다음 N 개의 줄에 뱀이 머리를 어떻게 회전하는지에 대한 정보가 주어진다. 
    
    i(1 ≤ i ≤ N)번째 줄에 정수 ti(1 ≤ ti ≤ 2 · 108)와 diri 가 차례로 주어지며 diri 는 문자 L, 또는 R 중 하나이다. 뱀은 i = 1인 경우 출발, 
    
    그 외의 경우엔 i − 1번째 회전으로부터 ti 초 후에 diri 의 방향으로 머리를 회전하며, 만일 diri 가 L 이라면 왼쪽 (반시계방향)으로,
    
    R 이라면 오른쪽 (시계방향)으로 90도 회전한다.

출력
    
    첫 번째 줄에 답을 나타내는 값을 하나 출력한다. 이 값은 뱀이 출발한지 몇 초 후에 숨을 거두는지를 나타낸다.

예제 입력 1 

    3
    4
    2 L
    2 L
    1 L
    5 R

예제 출력 1 

    7

예제 입력 2 

    3
    3
    2 L
    4 L
    4 R

예제 출력 2 

    6
    
풀이 알고리즘

    정말 많이 틀리고 오래걸리고 힘들었던 문제 '뱀' 이였습니다..
    
    처음에는 배열로 풀어보려고했으나 문제의 범위가 너무나 컸기때문에 배열을 쓸 수 없었고, 좌표 기반으로 탐색을 진행하여
    
    시뮬레이션을 돌려야 하는 문제였습니다.
    
    제가 생각한 문제의 풀이는 다음과 같았습니다. 
    
    뱀이 이동한 좌표를 배열로 기록하여 다음 뱀의 움직임 동안 전의 움직임 중 닿은곳이 있는지 확인하고
    
    닿았다면 마지막 위치와 닿은 위치의 차이값을 구하여 이동전 시간 + 차이값 으로 답을 출력하기.
    
    위의 풀이에서 생길 수 있는 케이스는 다음과 같습니다. 
    
    (좌표는 위,왼쪽으로 갈수록 작아지고 아래,오른쪽으로 갈수록 커집니다)
    
    1. 전의 움직임이 수직선
    
      (1) 나의 움직임이 ->
      
         이 케이스의 경우 수직-수평 선이 만나야 하므로 수직선의 x좌표와 수평선의 x좌표가 일치하는 곳이
         
         있어야하고, 일치하는 곳이 있다면 수직선의 y좌표가 수평선의 y범위 내에 있어야 합니다.
         
         범위내에 존재한다면 닿았을 때 걸리는 시간 = (수직선의 y좌표 - 움직이기 시작한 y좌표)
         
      
      (2) 나의 움직임이 <-
      
          이 케이스의 경우 수직-수평 선이 만나야 하므로 수직선의 x좌표와 수평선의 x좌표가 일치하는 곳이
         
         있어야하고, 일치하는 곳이 있다면 수직선의 y좌표가 수평선의 y범위 내에 있어야 합니다.
         
         범위내에 존재한다면 닿았을 때 걸리는 시간 = (움직이기 시작한 y좌표 - 수직선의 y좌표)
      
      (3) 나의 움직임이 ↑
      
         이 케이스의 경우 수직-수직 선이 만나야 하므로 두 선의 y좌표가 일치해야 합니다.
         
         또한 나의 움직임이 위로 향하고 있기 때문에 현재 나의 x좌표에서 수직선의 아래쪽
         
         x좌표 끝점에서 만나게 됩니다.
         
         그러면 시간 = (수직선의 아래 x좌표 - 움직이기 시작한 x좌표)
         
      (4) 나의 움직임이 ↓
      
        이 케이스의 경우 수직-수직 선이 만나야 하므로 두 선의 y좌표가 일치해야 합니다.
         
         또한 나의 움직임이 아래로로 향하고 있기 때문에 현재 나의 x좌표에서 수직선의 위쪽
         
         x좌표 끝점에서 만나게 됩니다.
         
         그러면 시간 = (움직이기 시작한 x좌표 - 수직선의 위 x좌표)
      
    2. 전의 움직임이 수평선
    
      (1) 나의 움직임이 ->
      
        이 케이스의 경우 수평-수평 선이 만나게 되므로 두 선의 x값이 같아야 만날 수 있고,
        
        오른쪽으로 향하는 선이므로 기존의 수평선의 왼쪽 끝점과 만나게 됩니다.
        
        그럴경우 시간 = 전의 수평선 왼쪽 y좌표 - 움직이기 시작한 y좌표
     
      (2) 나의 움직임이 <-
      
         이 케이스의 경우 수평-수평 선이 만나게 되므로 두 선의 x값이 같아야 만날 수 있고,
        
        왼쪽으로 향하는 선이므로 기존의 수평선의 오른쪽 끝점과 만나게 됩니다.
        
        그럴경우 시간 = 움직이기 시작한 y좌표 - 전의 수평선 오른쪽 y좌표
      
      (3) 나의 움직임이 ↑
      
        이 케이스의 경우 수평-수직 선이 만나게 되므로, 수평선의 y범위 내에 수직선의 y좌표가 존재해야하고
        
        수직선의 x범위 내에 수평선의 x좌표가 존재해야 합니다.
        
        그리고 수직선이 위로 향하므로 걸리는 시간은
        
        시간 = 움직이기 시작한 수직선의 시간 x좌표 - 수평선의 x좌표
        
      (4) 나의 움직임이 ↓
      
        이 케이스의 경우 수평-수직 선이 만나게 되므로, 수평선의 y범위 내에 수직선의 y좌표가 존재해야하고
        
        수직선의 x범위 내에 수평선의 x좌표가 존재해야 합니다.
        
        그리고 수직선이 아래로 향하므로 걸리는 시간은
        
        시간 = 수평선의 x좌표 - 움직이기 시작한 수직선의 시간 x좌표 
        
      이 밖에도 여러 고려해야는 점이 있습니다.
      
      [1] 명령어를 받고 움직이기 시작할 때, 현재 움직임의 시작점은 이전 움직임의 끝점과 좌표가 같습니다.
      
      이 케이스를 처리하지않으면 닿는 시간이 게속 0초가 발생하게됩니다.
      
      이전에 그렸던 선분과 현재 움직임은 만날일이 없으므로, 이전 움직임을 탐색할 때 바로 직전의 움직임은
      
      확인하지 않도록 합니다.
      
      [2] 선분을 만났을때 처리해야할 내용
      
      움직임을 실행할 때, 처음 만나는 선분이 가장 가까이에 존재하는 선분이라는 보장이 없습니다.
      
      그렇기 때문에 전의 모든 움직임을 확인하면서 최소값을 찾아야 합니다.
      
      [3] 값의 범위
      
      L의 최대값은 1억이지만 시간의 값으로 주어지는 t의 값의 범위가 2억까지 이므로 거리를 계산할 때
      
      1억 * 2억의 거리가 나올 수 있습니다.
      
      그러므로 값을 long long으로 처리해주거나, 값의 범위가 너무 커질경우 해당 값을 처리해주는 알고리즘이
      
      필요합니다.
      
      [4] 모든 명령어가 끝났을 때
      
      모든 명령어가 끝나도 뱀이 자신의 몸에 닿지 않을경우가 있습니다.
      
      해당경우를 처리해주지 않으면 뱀이 평생 죽지않으므로, 해당 케이스에는 맵의 끝까지 뱀이 이동할 수 있도록
      
      한 뒤 시간을 출력하는 방식으로 구현해야 합니다.
      
풀이 인증샷

![image](https://user-images.githubusercontent.com/57944215/209438931-bdbf3c94-c6e3-4dbf-80a4-0d9c061bc43f.png)
