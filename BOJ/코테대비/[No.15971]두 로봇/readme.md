문제 사이트 : https://www.acmicpc.net/problem/15971

문제 설명 :

    2018년 강원도에서 새로운 동굴이 발견되었다. 
    
    이 동굴에는 총 N개의 넓은 방이 존재하며 좁은 통로로 서로 연결되어 있는 것으로 밝혀졌다. 
    
    N개의 방은 1번부터 N번까지의 번호를 붙여 1번 방, 2번 방, …, N번 방으로 부른다. 통로는 정확히 N-1개가 발견되었는데, 
    
    각각 서로 다른 두 방 사이를 연결시켜 주며 중간에 다른 통로와 이어지는 경우는 없다고 한다. 
    
    또한 이 통로들을 이용하여 임의의 두 방 사이를 이동하는 것이 가능하며, 
    
    임의의 두 방 사이를 이동할 때 같은 통로를 두 번 이상 지나지 않는 경로는 유일한 것으로 밝혀졌다.

    새로 발견된 동굴을 조사하기 위해 동굴 탐사 로봇 두 대를 이용하기로 하였다. 
    
    두 로봇은 어떤 시점이 되면 각자가 획득한 정보를 공유하기 위해 통신을 해야 한다. 
    
    두 로봇이 서로 통신을 하기 위해서는 동굴 내의 같은 통로 위에 위치해야만 한다. 
    
    참고로 임의의 통로의 양 끝에 위치한 두 방들도 그 통로 위에 위치해 있다고 간주한다.

![upload acmicpc](https://user-images.githubusercontent.com/57944215/183918794-8c0f7242-c805-45a5-83d5-298601584065.png)

<그림 1> 동굴 내부를 간략히 표현한 그림

    <그림 1>은 방이 9개인 동굴 내부를 간략하게 나타낸 예이다. 
    
    <그림 1>에서 방은 원으로 표현되어 있으며 원 안의 수는 방 번호이다.
    
    8개의 통로는 두 원 사이의 선분으로 표시되어 있으며 그 위의 정수 값이 통로의 길이이다.
    
    예를 들어, 5번 방과 9번 방 사이에 길이가 6 인 통로가 있음을 알 수 있다.
    
    만약 두 로봇이 1번 방과 9번 방에 위치해 있다면, 각각 2번 방과 5번 방으로 이동한 후 통신할 수 있으며 이때 이동한 거리의 합은 14로 최소이다.

    동굴 내의 통로에 대한 정보와 두 로봇의 현재 위치가 입력으로 주어질 때, 서로 통신하기 위해 이동해야 하는 거리의 합의 최솟값을 계산하는 프로그램을 작성하시오.

    동굴의 각 통로는 양 끝에 위치한 두 방의 번호와 그 길이로 주어진다. 두 로봇의 위치는 방 번호로 주어진다.

입력

    표준 입력으로 동굴의 방의 개수 N과 두 로봇이 위치한 방의 번호가 세 개의 양의 정수로 공백으로 분리되어 첫 줄에 주어진다.
    
    이후 동굴의 통로 N-1개가 한 줄에 하나씩 주어진다. 
    
    각 통로는 세 개의 양의 정수로 공백으로 분리되어 한 줄에 주어지며, 
    
    앞 두 정수는 통로의 양 끝에 위치한 방의 번호를, 세 번째 정수는 그 통로의 길이를 의미한다.

출력

    표준 출력으로 두 로봇이 서로 통신하기 위해 현재 위치에서 이동해야 하는 거리의 합의 최솟값을 정수로 출력한다.

제한

    모든 서브태스크에서 1 ≤ N ≤ 100,000이며, 통로의 길이는 1,000을 넘지 않는다.



예제 입력 1 

    5 1 5
    1 2 1
    2 3 2
    3 4 3
    4 5 4

예제 출력 1 

    6

예제 입력 2 

    9 1 9
    1 2 8
    2 3 6
    2 4 5
    2 5 10
    9 5 6
    6 5 14
    6 7 7
    8 6 7

예제 출력 2 

    14
   
풀이 알고리즘

    주어진 트리형태의 데이터에서 두 노드에 존재하는 로봇들이 최소비용으로 같은 간선위에 존재하도록 하는 문제였습니다.
    
    트리형태의 구조이기 때문에, 한 점에서 dfs탐색으로 통해 다른 한 점을 찾으면 정답이라고 생각하였고, 한 점을 찾은 이후에는 더이상 탐색이 필요없기 때문에
    
    프로그램을 종료시키는 방향으로 구현을 시작했었는데, 바로 "틀렸습니다" 라는 단어를 맞이할 수 있었습니다.
    
    그래서 코드를 계속 수정해 본결과, 테스트 케이스 중 목적지로 향하는 간선이 최소 두개 존재한다는 것을 알게되었고, 프로그램을 종료시키지 않고 모든 탐색이 끝날떄까지
    
    동작시켜서 최소거리를 찾는 방향으로 진행한 결과 문제를 맞을 수 있었습니다.
    
    풀이 알고리즘은 다음과 같습니다.
    
        1. 한 점에서 다른 점까지 가는 DFS탐색을 실시한다.

        2. DFS탐색을 실시하면서 존재하는 가장 긴 간선을 저장한다.(두 봇이 해당 간선을 기준으로 서로 움직이면 그것이 최소거리)

        3. 다른 한 점에 도착하면 answer = 현재까지 비용 - 최대 거리를 저장한다.

        4. 다른 DFS탐색에서 다른 한 점에 또 도착하게 된다면 이전에 구했던 answer 과 현재까지 비용 - 최대거리 를 하여 최소값을 answer에 저장

        5. 모든 DFS탐색이 종료되면 answer출력
    
    
구 현

    #include <iostream>
    #include <string>
    #include <vector>
    #include <queue>
    #include <algorithm>
    using namespace std;



    struct Node {
      int idx;
      int cost;
    };
    int N, pos1, pos2;
    vector<vector<Node>> v(100010);
    int root[100010];
    bool check[100010];
    bool checker = 0;
    int cnt;
    int mini = 21e8;

    void dfs(int start, int end, int sum, int max_leng) {

      if (start == end) {
        if(sum-max_leng < mini)
          mini = sum - max_leng;
        return;
      }

      for (int a = 0; a < v[start].size(); ++a) {
        if (!check[v[start][a].idx]) {
          check[v[start][a].idx] = 1;
          dfs(v[start][a].idx, end, sum + v[start][a].cost, max(v[start][a].cost, max_leng));
          check[v[start][a].idx] = 0;
        }

      }
    }
    void input() {
      cin >> N >> pos1 >> pos2;
      for (int a = 1; a < N; ++a) {
        int from, to, cost;
        cin >> from >> to >> cost;
        v[from].push_back({ to,cost });
        v[to].push_back({ from,cost });
      }
    }

    int main() {
      ios::sync_with_stdio(false);
      cin.tie(NULL);
      cout.tie(NULL);

      input();
      if (N == 1)
        mini = 0;
      else
        dfs(pos1, pos2, 0, 0);
      cout << mini;
      return 0;
    }
