문제 사이트 : https://www.acmicpc.net/problem/1765

문제 설명 : 

    닭싸움은 월드의 전통이다. 
    
    이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 
    
    그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 
    
    닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.

        내 친구의 친구는 내 친구이다.
        내 원수의 원수도 내 친구이다.
    
    이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.

    학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.

입력

    첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000) 

    둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)

    다음 m개의 줄에는 한 줄에 한 개씩, 
    
    학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p < q ≤ n)

    첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다. 

    입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.

출력

    첫째 줄에, 가능한 최대 팀 개수를 출력한다.

예제 입력 1 

    6
    4
    E 1 4
    F 3 5
    F 4 6
    E 1 2

예제 출력 1 

    3
    
풀이 알고리즘 

    주어진 조건에 맞도록 팀을 구성하고, 가능한 최대 팀 개수를 출력하는 문제 '닭싸움 팀 정하기' 입니다.
    
    이 문제의 팀 조건은 간단합니다. 
      
      1. 내 친구의 친구는 친구다.
      
      2. 내 원수의 원수도 내 친구이다.
      
    위 조건을 잘 생각해보면, A가 B의 친구라면, B의친구 C도 A의친구이고, C의 친구 D도 A의 친구입니다.
    
    따라서 A와 연결된 모든 친구들은 하나의 팀으로 구성되고, A의 원수의 원수인 학생은 A의 친구가 됩니다.
    
    그러므로 풀이 알고리즘은 다음과 같습니다.
    
    1. (입력) 입력값 (관계, 친구 A, 친구B) 가 주어졋을 때,
    
       A와 B의 관계에 따라 good 혹은 bad 벡터에 vector[A].push_back(B) vector[B].push_back(A)를 하여
       
       A와 B가 일방적인 친구 혹은 원수가 아닌 양쪽 모두 서로의 정보를 알 수 있게 처리합니다
       
    2. (알고리즘) for문을 통해 1 부터 N까지 탙색하고, 현재 위치의 학생이 한번도 호출된적 없다면 팀의 갯수를 하나 증가시킵니다.
    
    3. (알고리즘) 현재 위치는 학생과 친구인 학생들을 모두 방문처리합니다.
    
    4. (알고리즘) 현재 위치의 학생과 원수인 학생의 원수들을 모두 현재 위치의 친구로 방문처리 합니다.
    
    5. 모든 N에 대하여 탐색이 종료되면 현재까지 구한 팀의 갯수를 출력합니다.
    
풀이 인증샷 

![image](https://user-images.githubusercontent.com/57944215/217528161-bca8a221-2e04-4937-921c-f2d580db22ef.png)

       
       
