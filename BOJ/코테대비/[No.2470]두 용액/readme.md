문제 사이트 : https://www.acmicpc.net/problem/2470

문제 설명 :

    KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 
    
    각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  
    
    산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 
    
    알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

    같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다.
    
    이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 

    예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는
    
    특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고,
    
    이 용액이 특성값이 0에 가장 가까운 용액이다.
    
    참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이
    
    0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

    산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 
    
    이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는
    
    두 용액을 찾는 프로그램을 작성하시오.

입력

    첫째 줄에는 전체 용액의 수 N이 입력된다.
    
    N은 2 이상 100,000 이하이다. 
    
    둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다.
    
    이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. 
    
    N개의 용액들의 특성값은 모두 다르고, 
    
    산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.

출력

    첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 
    
    출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 
    
    특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 
    
    그 중 아무것이나 하나를 출력한다.

예제 입력 1 

    5
    -2 4 -99 -1 98

예제 출력 1 

    -99 98

풀이 알고리즘

    음수와 양수로 입력되는 값들 중 두 값을 골라 절대값이 0에 가장 가까운 두 값을 찾고 출력하는
    
    문제였습니다.
    
    2중for문을 사용하여 답을 구하려고 할 경우 입력값의 갯수가 최대 100,000개 이므로
    
    100,000*100,000 번 for문이 돌기 떄문에 시간초과가 발생할 수 있는 문제였습니다.
    
    시간초과가 발생하지 않게 하기 위해 Two Pointer 풀이 방식을 통해 값을 하나하나 탐색하는 방식으로
    
    구현하였고, 포인터가 움직일 떄 값들의 규칙이 생기게 하기 위해 입력받은 값을
    
    오름차순으로 sort하여 음수의 경우 index가 증가할경우 값이 커지고, index가 작아질 경우
    
    값이 작아지도록 하여 포인터들의 이동에 규칙을 만들어 주었습니다.
    
    알고리즘
    
      1. 입력값을 sort한 이후 시작과 끝에 포인터를 줌.
      
      2. 포인터에 위치한 값들끼리 더한 후, 0일 경우 탐색종료
        (0에 도달하는 것이 목표이고, 값이 같을 경우 절대값의 합이 가장 큰 수가 정답이므로
        가장 처음에 발견된 숫자 조합이 정답)
        
        아닐 경우 현재까지 찾은 0에 가까운 절대값과 비교하여 더 작은값을 정답으로 갱신하고
      
      3. 더한 값이 0보다 크면 오른쪽 포인터의 인덱스를 하나 줄여줌(값이 0초과 이므로 감소시켜줘야함)
      
      4. 더한 값이 0보다 작으면 왼쪽 포인터의 인덱스를 하나 증가
      
      5. 왼쪽 포인터가 오른쪽 포인터의 위치와 같아지거나 커지면 종료
    
구 현

    #include<iostream>
    #include<string>
    #include<algorithm>
    #include<queue>

    using namespace std;

    int N, M, T;
    vector<int> arr;

    int tot = -1;
    int degree = 21e8;
    int l_idx, r_idx;
    void solve() {
      int s = 0;
      int e = arr.size() - 1;

      while (s < e) {
        int sum = arr[s] + arr[e];
        if (abs(sum) < degree) {
          degree = abs(sum);
          l_idx = s;
          r_idx = e;
        }
        if (sum == 0)
          break;
        if (sum > 0)
          --e;
        else if (sum < 0)
          ++s;
      }
      cout << arr[l_idx] << " " << arr[r_idx];
    }
    void input() {
      cin >> N;

      int temp;
      for (int a = 0; a < N; ++a) {
        cin >> temp;
        arr.push_back(temp);
      }

      sort(arr.begin(), arr.end());

    }
    int main()
    {
      ios::sync_with_stdio(false);

      cin.tie(NULL);
      cout.tie(NULL);

      input();
      solve();
      return 0;

    }
