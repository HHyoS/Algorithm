문제 설명 : https://www.acmicpc.net/problem/14502

문제 설명 :

    인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 
    
    다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을
    
    세우려고 한다.

    연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 
    
    직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 
    
    연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 

    일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 
    
    인접한 빈 칸으로 모두 퍼져나갈 수 있다. 
    
    새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

    예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.

    2 0 0 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 0 1 0 0
    0 1 0 0 0 0 0
    0 0 0 0 0 1 1
    0 1 0 0 0 0 0
    0 1 0 0 0 0 0
    이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.

    2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.

    2 1 0 0 1 1 0
    1 0 1 0 1 2 0
    0 1 1 0 1 0 0
    0 1 0 0 0 1 0
    0 0 0 0 0 1 1
    0 1 0 0 0 0 0
    0 1 0 0 0 0 0

    바이러스가 퍼진 뒤의 모습은 아래와 같아진다.

    2 1 0 0 1 1 2
    1 0 1 0 1 2 2
    0 1 1 0 1 2 2
    0 1 0 0 0 1 2
    0 0 0 0 0 1 1
    0 1 0 0 0 0 0
    0 1 0 0 0 0 0

    벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 
    
    위의 지도에서 안전 영역의 크기는 27이다.

    연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.

입력

    첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)

    둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.

    빈 칸의 개수는 3개 이상이다.

출력

    첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.

예제 입력 1 

    7 7
    2 0 0 0 1 1 0
    0 0 1 0 1 2 0
    0 1 1 0 1 0 0
    0 1 0 0 0 0 0
    0 0 0 0 0 1 1
    0 1 0 0 0 0 0
    0 1 0 0 0 0 0

예제 출력 1 

    27

예제 입력 2 

    4 6
    0 0 0 0 0 0
    1 0 0 0 0 2
    1 1 1 0 0 2
    0 0 0 0 0 2

예제 출력 2 

    9

예제 입력 3

    8 8
    2 0 0 0 0 0 0 2
    2 0 0 0 0 0 0 2
    2 0 0 0 0 0 0 2
    2 0 0 0 0 0 0 2
    2 0 0 0 0 0 0 2
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

예제 출력 3 

    3
    
풀이 알고리즘

    주어진 조건에 맞춰서 기둥을 정확히 3개 세우고, 바이러스가 퍼진 후 안전구역의 크기가 최대가
    
    되도록 하는 문제였습니다.
    
    문제를 풀기위해 지문을 읽어보며 이 문제를 2가지로 나눠서 생각했습니다.
    
    1. dfs를 사용하여 기둥세우기
    
    2. bfs를 사용하여 바이러스 퍼트리기
    
    1.의 구현을 위해 2중for문과 dfs를 탐색을 통해 현재 위치부터 맵의 끝까지 탐색하면서 안전구역, 즉 값이 0인 지역에 기둥을 세우는 탐색을 진행하면서 기둥 세우기를 진행하였습니다.
    
    기둥세우기를 진행하면서 dfs의 매개변수는 dfs(int x,int y ,int cnt), x,y는 전에 기둥을 세운 위치, cnt는 기둥을 세운 갯수를 의미합니다.
    
    이 과정에서 문제가 발생했었는데, for(int a = x; a < N; ++a){ for(int b =y; y < M; ++y)로 선언하여 2중 for문을 돌다보니 y쪽 for문을 돈 이후 x가 증가해도
    
    0부터 탐색하는 것이 아닌 x+1,y 부터 탐색을 시작하여 발생한 문제였습니다.
    
    그래서 for(int a = x; a < N; ++a){ for(int b =y; y < M; ++y) if(a==x && b <y ) continue; 문장을 추가하여 현재 탐색위치의 a좌표가 x일떄만 b가 y이상일 때 탐색하도록
    
    하엿고, 그 외의 경우에는 0부터 탐색하도록 하여 문제를 해결하였습니다.
    
    2.의 구현은 일반적인 bfs탐색을 진행하여 바이러스를 퍼트렸습니다.
    
    그 이후에는 맵에 존재하는 안전구역의 갯수를 탐색하여 최대 안전구역을 찾는 과정을 반복하여 문제를 해결하였습니다.
    
    
 구 현
 
    #include <iostream>
    #include <string>
    #include <vector>
    #include <queue>
    #include <algorithm>
    using namespace std;


    struct Node {
      int x;
      int y;
    };
    int N, M;
    int map[9][9];
    int ans = -1;
    int mov[4][2] = { {-1,0},{0,1},{1,0},{0,-1} };
    vector<Node> virus;
    int bfs() {

      queue<Node> que;
      bool used[9][9] = {};
      for (int a = 0; a < virus.size(); ++a) {
        que.push(virus[a]);
      }
      int cnt = 0;
      while (!que.empty()) {
        int x = que.front().x;
        int y = que.front().y;
        que.pop();

        for (int a = 0; a < 4; ++a) {
          int xx = x + mov[a][0];
          int yy = y + mov[a][1];

          if (xx >= 0 && xx < N && yy >= 0 && yy < M && map[xx][yy] == 0 && !used[xx][yy]) {
            used[xx][yy] = 1;
            que.push({ xx,yy });
          }
        }
      }

      for (int a = 0; a < N; ++a) {
        for (int b = 0; b < M; ++b) {
          if (map[a][b] == 0 && !used[a][b]) {
            ++cnt;
          }
        }
      }


      return cnt;
    }
    void dfs(int x,int y,int cnt) {
      if (cnt == 3) {
        int num = bfs();
        if (num > ans)
          ans = num;
        return;
      }

      ++y;
      if(y >= M){
        y = 0;
        x++;
        if (x >= N)
          return;

      }

      for (int a = x; a < N; ++a) {
        for (int b = 0; b < M; ++b) {
          if (a == x && b < y) continue;
          if (map[a][b] == 0) {
            map[a][b] = 1;
            dfs(a, b, cnt + 1);
            map[a][b] = 0;
          }
        }
      }
    }

    void solve() {
      for (int a = 0; a < N; ++a) {
        for (int b = 0; b < M; ++b) {
          if (map[a][b] == 0) {
            map[a][b] = 1;
            dfs(a,b, 1);
            map[a][b] = 0;
          }
        }
      }
    }
    void input() {
      cin >> N >> M;
      for (int a = 0; a < N; ++a) {
        for (int b = 0; b < M; ++b) {
          cin >> map[a][b];
          if (map[a][b] == 2) {
            virus.push_back({ a,b });
          }
        }
      }
    }

    int main() {
      ios::sync_with_stdio(false);
      cin.tie(NULL);
      cout.tie(NULL);

      input();
      solve();
      cout << ans;
      return 0;
    }

    
