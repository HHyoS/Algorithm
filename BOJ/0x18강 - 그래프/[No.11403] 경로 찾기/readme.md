# 문제 사이트
- https://www.acmicpc.net/problem/11403

# 문제 설명

## 문제
    가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 길이가 양수인 경로가 있는지 없는지 구하는 프로그램을 작성하시오.
## 입력
    첫째 줄에 정점의 개수 N (1 ≤ N ≤ 100)이 주어진다.
    둘째 줄부터 N개 줄에는 그래프의 인접 행렬이 주어진다.
    i번째 줄의 j번째 숫자가 1인 경우에는 i에서 j로 가는 간선이 존재한다는 뜻이고,
    0인 경우는 없다는 뜻이다.
    i번째 줄의 i번째 숫자는 항상 0이다.
## 출력
    총 N개의 줄에 걸쳐서 문제의 정답을 인접행렬 형식으로 출력한다.
    정점 i에서 j로 가는 길이가 양수인 경로가 있으면 i번째 줄의 j번째 숫자를 1로,
    없으면 0으로 출력해야 한다.
## 예제 입력 1
    3
    0 1 0
    0 0 1
    1 0 0
## 예제 출력 1
    1 1 1
    1 1 1
    1 1 1

# 풀이 설명

## 입력
    정점의 개수 N과 N×N 크기의 인접 행렬.
## 출력
    각 정점 쌍 (i, j)에 대해 i에서 j로 가는 경로가 존재하면 1, 없으면 0을 출력하는 N×N 크기의 행렬.
## 풀이 알고리즘
    플로이드-워셜 알고리즘은 모든 정점 쌍 간의 최단 경로를 찾는 알고리즘이지만,
    이 문제에서는 경로의 존재 여부만 판단하면 되므로, 간단한 논리 연산으로 구현할 수 있음.
### 입력 처리
    인접 행렬을 입력받아 graph 배열에 저장
### 경로 탐색
    모든 정점 k에 대해, 각 정점 쌍 (i, j)에 대해 i에서 k를 거쳐 j로 가는 경로가 존재하는지를 확인하여 graph[i][j]를 갱신
### 출력
    갱신된 graph 배열을 출력

# 풀이 코드

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N;
    cin >> N;

    vector<vector<int>> graph(N, vector<int>(N));

    // 인접 행렬 입력
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N; ++j)
            cin >> graph[i][j];

    // 플로이드-워셜 알고리즘을 이용한 경로 탐색
    for (int k = 0; k < N; ++k)
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                if (graph[i][k] && graph[k][j])
                    graph[i][j] = 1;

    // 결과 출력
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j)
            cout << graph[i][j] << ' ';
        cout << '\n';
    }

    return 0;
}
```
