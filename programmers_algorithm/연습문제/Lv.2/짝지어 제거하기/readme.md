문제 사이트 : 


문제 설명 :

    짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 
    
    먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다.
    
    그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 
    
    이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 
    
    문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 
    
    반환하는 함수를 완성해 주세요. 
    
    성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

    예를 들어, 문자열 S = baabaa 라면

        b aa baa → bb aa → aa →

    의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

제한사항

    문자열의 길이 : 1,000,000이하의 자연수
    문자열은 모두 소문자로 이루어져 있습니다.

입출력 예

    s	      result
    baabaa	1
    cdcd	  0

입출력 예 설명

입출력 예 #1

    위의 예시와 같습니다.

입출력 예 #2

    문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.

풀이 알고리즘 

    주어진 조건에 맞게 문자열을 쌍을 제거하고, 모든 문자열을 제거할 수 있는지 확인하는 문제 '짝지어 제거하기'입니다.
    
    문제에서 조건을 계속 수행하기 위해서는 이전 문자열이 무엇이었는지 저장하고, 현재 문자열과 비교하는 과정이 필요합니다.
    
    또한 문자열이 제거되었을 경우 이전 문자열을 또 참조해야 하기떄문에 이전에 제거되지 않은 문자열을 관리하고, 비교할 수 있는 방법이
    
    필요합니다.
    
    그 방법에 대해 고민한 결과 Stack 자료구조를 사용하여 이전 문자열을 저장하고, stack의 top에 있는 값과 현제 문자열을 비교하여 처리하는 방식으로
    
    문제를 풀 수 잇다고 생각했습니다.
    
    풀이 알고리즘 입니다.
    
        1. stack<char> st선언 후 s[0]의 값을 초기값으로 세팅
        
        2. for문을 돌며 1번인덱스부터 s.size()-1 인덱스까지 s문자열을 탐색 실시
        
        3. 만약 st이 비어있거나, st의 마지막 값이 현재 인덱스 값과 다르다면 stack 에 현재 문자열 push
        
        4. 만약 st의 마지막 값과 현재 인덱스 값이 같다면 st의 마지막값 pop
        
        5. 3 ~ 4 를 s.size()-1 까지 모두 탐색
        
        6. 2의 for문이 종료 후 st에 값이 남아있으면 문자열 제거 불가능하므로 0 return
        
        7. st이 비어있다면 모든 문자열이 제거된 것 이므로 1 return
        
풀이 인증샷 

![image](https://user-images.githubusercontent.com/57944215/236846979-4228a915-82ec-487c-bb39-bd59130f24bd.png)

