문제 사이트 : https://school.programmers.co.kr/learn/courses/30/lessons/159993

문제 설명 :

    1 x 1 크기의 칸들로 이루어진 직사각형 격자 형태의 미로에서 탈출하려고 합니다. 
    
    각 칸은 통로 또는 벽으로 구성되어 있으며, 
    
    벽으로 된 칸은 지나갈 수 없고 통로로 된 칸으로만 이동할 수 있습니다. 
    
    통로들 중 한 칸에는 미로를 빠져나가는 문이 있는데, 이 문은 레버를 당겨서만 열 수 있습니다. 
    
    레버 또한 통로들 중 한 칸에 있습니다. 
    
    따라서, 출발 지점에서 먼저 레버가 있는 칸으로 이동하여 레버를 당긴 후 미로를 빠져나가는 문이 있는 칸으로 이동하면 됩니다.
    
    이때 아직 레버를 당기지 않았더라도 출구가 있는 칸을 지나갈 수 있습니다. 
    
    미로에서 한 칸을 이동하는데 1초가 걸린다고 할 때, 최대한 빠르게 미로를 빠져나가는데 걸리는 시간을 구하려 합니다.

    미로를 나타낸 문자열 배열 maps가 매개변수로 주어질 때, 
    
    미로를 탈출하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 
    
    만약, 탈출할 수 없다면 -1을 return 해주세요.

제한사항

    5 ≤ maps의 길이 ≤ 100
    5 ≤ maps[i]의 길이 ≤ 100
    
    maps[i]는 다음 5개의 문자들로만 이루어져 있습니다.
    
        S : 시작 지점
        E : 출구
        L : 레버
        O : 통로
        X : 벽

    시작 지점과 출구, 레버는 항상 다른 곳에 존재하며 한 개씩만 존재합니다.
    출구는 레버가 당겨지지 않아도 지나갈 수 있으며, 모든 통로, 출구, 레버, 시작점은 여러 번 지나갈 수 있습니다.
    
입출력 예

    maps	                                    result
    ["SOOOL","XXXXO","OOOOO","OXXXX","OOOOE"]	16
    ["LOOXS","OOOOX","OOOOO","OOOOO","EOOOO"]	-1

입출력 예 설명

입출력 예 #1

    주어진 문자열은 다음과 같은 미로이며

<img width="464" alt="214443486-cb2b84a4-afc6-4b25-8da2-645a853859f1" src="https://github.com/HHyoS/Algorithm/assets/57944215/5d54120f-ac95-438c-a40e-9c280806681f">

다음과 같이 이동하면 가장 빠른 시간에 탈출할 수 있습니다.

<img width="203" alt="207090680-93289071-da4f-4126-9c31-066c1d4d3802" src="https://github.com/HHyoS/Algorithm/assets/57944215/3ca0b99c-f3e3-4af9-aabd-907d4f9cf32d">

    4번 이동하여 레버를 당기고 출구까지 이동하면 총 16초의 시간이 걸립니다. 따라서 16을 반환합니다.

입출력 예 #2

주어진 문자열은 다음과 같은 미로입니다.

<img width="463" alt="214443892-1e7734e9-b4c8-49af-ba29-aa5597039617" src="https://github.com/HHyoS/Algorithm/assets/57944215/a0654203-be4b-442b-a66f-d0fadaa9f63f">

    시작 지점에서 이동할 수 있는 공간이 없어서 탈출할 수 없습니다. 따라서 -1을 반환합니다.

풀이 알고리즘 :

    주어진 조건에 따라 출발지점 - 레버 - 탈출 을 할 수 있는 최단거리의 길이를 구하는 문제 '미로 탈출' 입니다.
    
    이 문제를 보면서 제가 생각한 풀이 방법은 두가지입니다.

        1. 출발지점 - 레버, 레버 - 탈출을 구하는 두개의 bfs탐색을 돌린다.

        2. 레버에서 시작하는 bfs탐색을 진행하여 출발,탈출 지점을 가는 최단거리를 구한뒤 더한다.

    첫번째 방법으로 풀이할 경우, 코드가 길어지고 방문했던 배열을 초기화하는 번거러움이 있기 때문에
    
    두번쨰 방법을 사용하여 상대적으로 깔끔한 코드 풀이를 진행하였습니다.
    
    풀이알고리즘 입니다.
    
        1. 입력받은 맵의 정보 중 레버의 위치에 해당하는 'L' 문자열의 위치를 찾는다.
        
        2. L을 기준으로 bfs탐색을 진행!
        
        3. 만약 S나 E를 만나면 해당 값을 만나기 위해 이동한 거리 각각 변수로 저장
          ex) LeverToStart(레버->S) LeverToEnd(레버->E) -> 두 변수의 초기값은 -1로 설정
        
        4. 맵의 모든 위치에 대해 탐색이 종료되었을 경우, 변수의 값이 초기값인 -1 일경우 answer에 -1 반환
          -> 초기값인 -1이 바뀌지 않았을 경우, 해당 위치에 방문이 불가능
          
        5. 아닐경우 LeverToStart + LeverToEnd를 더한 값을 정답으로 반환
      
풀이 인증샷

![image](https://github.com/HHyoS/Algorithm/assets/57944215/833a2565-2771-4528-83c0-48790a2efa25)
